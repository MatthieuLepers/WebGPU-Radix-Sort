{"version":3,"file":"radix-sort.es.js","sources":["../src/utils.ts","../src/shaders/PrefixSum.ts","../src/shaders/optimizations/PrefixSumNoBankConflict.ts","../src/AbstractKernel.ts","../src/PrefixSumKernel.ts","../src/shaders/CheckSort.ts","../src/CheckSortKernel.ts","../src/shaders/RadixSort.ts","../src/shaders/optimizations/RadixSortLocalShuffle.ts","../src/shaders/RadixSortReorder.ts","../src/RadixSortKernel.ts"],"sourcesContent":["export type WorkgroupSize = {\n  x: number;\n  y: number;\n}\n\nexport type DispatchSize = WorkgroupSize;\n\n/**\n * Find the best dispatch size x and y dimensions to minimize unused workgroups\n * \n * @param {GPUDevice} device - The GPU device\n * @param {int} workgroupCount - Number of workgroups to dispatch\n * @returns \n */\nexport function findOptimalDispatchSize(device: GPUDevice, workgroupCount: number) {\n  const dispatchSize = { \n    x: workgroupCount, \n    y: 1,\n  };\n\n  if (workgroupCount > device.limits.maxComputeWorkgroupsPerDimension) {\n    const x = Math.floor(Math.sqrt(workgroupCount));\n    const y = Math.ceil(workgroupCount / x);\n\n    dispatchSize.x = x;\n    dispatchSize.y = y;\n  }\n\n  return dispatchSize;\n}\n\nexport function createBufferFromData({ device, label, data, usage = 0 }: {\n  device: GPUDevice,\n  label: string,\n  data: number[],\n  usage: number,\n}) {\n  const dispatchSizes = device.createBuffer({\n    label,\n    usage,\n    size: data.length * 4,\n    mappedAtCreation: true,\n  });\n\n  const dispatchData = new Uint32Array(dispatchSizes.getMappedRange());\n  dispatchData.set(data);\n  dispatchSizes.unmap();\n\n  return dispatchSizes;\n}","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  temp[ELM_TID]      = select(items[ELM_GID], 0u, ELM_GID >= ELEMENT_COUNT);\n  temp[ELM_TID + 1u] = select(items[ELM_GID + 1u], 0u, ELM_GID + 1u >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n    // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    let last_offset = ITEMS_PER_WORKGROUP - 1u;\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (ELM_GID >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID] = temp[ELM_TID];\n\n  if (ELM_GID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID + 1u] = temp[ELM_TID + 1u];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nconst NUM_BANKS: u32 = 32u;\nconst LOG_NUM_BANKS: u32 = 5u;\n\nfn get_offset(offset: u32) -> u32 {\n  // return offset >> LOG_NUM_BANKS; // Conflict-free\n  return (offset >> NUM_BANKS) + (offset >> (2u * LOG_NUM_BANKS)); // Zero bank conflict\n}\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  let ai: u32 = TID;\n  let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1u);\n  let s_ai = ai + get_offset(ai);\n  let s_bi = bi + get_offset(bi);\n  let g_ai = ai + WID * 2u;\n  let g_bi = bi + WID * 2u;\n  temp[s_ai] = select(items[g_ai], 0u, g_ai >= ELEMENT_COUNT);\n  temp[s_bi] = select(items[g_bi], 0u, g_bi >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n  // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    var last_offset = ITEMS_PER_WORKGROUP - 1u;\n    last_offset += get_offset(last_offset);\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (g_ai < ELEMENT_COUNT) {\n    items[g_ai] = temp[s_ai];\n  }\n  if (g_bi < ELEMENT_COUNT) {\n    items[g_bi] = temp[s_bi];\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","import type { DispatchSize, WorkgroupSize } from './utils';\n\nexport interface IAbstractKernelOptions {\n  device: GPUDevice;\n  count: number;\n  workgroupSize?: WorkgroupSize;\n}\n\ninterface IKernelPipelineDefinition {\n  pipeline: GPUComputePipeline;\n  bindGroup: GPUBindGroup;\n  dispatchSize?: DispatchSize;\n}\n\nexport abstract class AbstractKernel {\n  public device: GPUDevice;\n\n  public count: number;\n\n  public workgroupSize: WorkgroupSize;\n\n  public pipelines: Array<IKernelPipelineDefinition> = [];\n\n  protected shaderModules: Record<string, GPUShaderModule> = {};\n\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n  }: IAbstractKernelOptions) {\n    this.device = device;\n    this.count = count;\n    this.workgroupSize = workgroupSize;\n  }\n\n  get workgroupCount(): number {\n    return Math.ceil(this.count / this.threadsPerWorkgroup);\n  }\n\n  get threadsPerWorkgroup(): number {\n    return this.workgroupSize.x * this.workgroupSize.y\n  }\n\n  get itemsPerWorkgroup(): number {\n    return 2 * this.threadsPerWorkgroup;\n  }\n\n  abstract dispatch(passEncoder: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset?: number): void;\n}\n","import { findOptimalDispatchSize } from './utils';\nimport type { WorkgroupSize, DispatchSize } from './utils';\nimport prefixSumSource from './shaders/PrefixSum';\nimport prefixSumSourceNoBankConflict from './shaders/optimizations/PrefixSumNoBankConflict';\nimport { AbstractKernel, type IAbstractKernelOptions } from './AbstractKernel';\n\ninterface IPrefixSumKernelOptions extends IAbstractKernelOptions {\n  data: GPUBuffer;\n  avoidBankConflicts?: boolean;\n}\n\nexport class PrefixSumKernel extends AbstractKernel {\n  /**\n   * Perform a parallel prefix sum on the given data buffer\n   * \n   * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\n   * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - Max number of elements to process\n   * @param {WorkgroupSize} workgroupSize - Workgroup size in x and y dimensions. (x * y) must be a power of two\n   * @param {GPUBuffer} data - Buffer containing the data to process\n   * @param {boolean} avoidBankConflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    data,\n    avoidBankConflicts = false\n  }: IPrefixSumKernelOptions) {\n    super({ device, count, workgroupSize });\n\n    if (Math.log2(this.threadsPerWorkgroup) % 1 !== 0) {\n      throw new Error(`workgroupSize.x * workgroupSize.y must be a power of two. (current: ${this.threadsPerWorkgroup})`);\n    }\n\n    this.shaderModules.prefixSum = this.device.createShaderModule({\n      label: 'prefix-sum',\n      code: avoidBankConflicts ? prefixSumSourceNoBankConflict : prefixSumSource,\n    })\n\n    this.createPassRecursive(data, count);\n  }\n\n  createPassRecursive(data: GPUBuffer, count: number) {\n    // Find best dispatch x and y dimensions to minimize unused threads\n    const workgroupCount = Math.ceil(count / this.itemsPerWorkgroup);\n    const dispatchSize = findOptimalDispatchSize(this.device, workgroupCount);\n\n    // Create buffer for block sums\n    const blockSumBuffer = this.device.createBuffer({\n      label: 'prefix-sum-block-sum',\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create bind group and pipeline layout\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      label: 'prefix-sum-bind-group',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: data },\n        },\n        {\n          binding: 1,\n          resource: { buffer: blockSumBuffer },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [ bindGroupLayout ],\n    });\n\n    // Per-workgroup (block) prefix sum\n    const scanPipeline = this.device.createComputePipeline({\n      label: 'prefix-sum-scan-pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.prefixSum,\n        entryPoint: 'reduce_downsweep',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ITEMS_PER_WORKGROUP': this.itemsPerWorkgroup,\n          'ELEMENT_COUNT': count,\n        },\n      },\n    });\n\n    this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize });\n\n    if (workgroupCount > 1) {\n      // Prefix sum on block sums\n      this.createPassRecursive(blockSumBuffer, workgroupCount);\n\n      // Add block sums to local prefix sums\n      const blockSumPipeline = this.device.createComputePipeline({\n        label: 'prefix-sum-add-block-pipeline',\n        layout: pipelineLayout,\n        compute: {\n          module: this.shaderModules.prefixSum,\n          entryPoint: 'add_block_sums',\n          constants: {\n            'WORKGROUP_SIZE_X': this.workgroupSize.x,\n            'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'ELEMENT_COUNT': count,\n          },\n        },\n      });\n\n      this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize });\n    }\n  }\n\n  getDispatchChain() {\n    return this.pipelines.flatMap((p) => [ p.dispatchSize!.x, p.dispatchSize!.y, 1 ]);\n  }\n\n  /**\n   * Encode the prefix sum pipeline into the current pass.\n   * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\n   *\n   * @param {GPUComputePassEncoder} pass\n   * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\n   * @param {number} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\n   */\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup, dispatchSize }, i) => {\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (!dispatchSizeBuffer) {\n        pass.dispatchWorkgroups(dispatchSize!.x, dispatchSize!.y, 1);\n      } else {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      }\n    });\n  }\n}\n","const checkSortSource = (isFirstPass = false, isLastPass = false, kernelMode = 'full') => /* wgsl */ `\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\n@group(0) @binding(2) var<storage, read> original: array<u32>;\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\noverride START_ELEMENT: u32;\n\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\n\n// Reset dispatch buffer and is_sorted flag\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reset(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  if (TID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  if (TID == 0) {\n    is_sorted = 0u;\n  }\n\n  let ELM_ID = TID * 3;\n\n  output[ELM_ID] = original[ELM_ID];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn check_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\n  let GID = TID + WID; // Global thread ID\n\n  // Load data into shared memory\n  ${ isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, input[GID], GID < ELEMENT_COUNT);\" }\n\n  // Perform parallel reduction\n  for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {\n    workgroupBarrier();  \n    if (TID % (2u * d) == 0u) {\n      s_data[TID] += s_data[TID + d];\n    }\n  }\n  workgroupBarrier();\n\n  // Write reduction result\n  ${ isLastPass ? last_pass(kernelMode) : write_reduction_result }\n}`\n\nconst write_reduction_result = /* wgsl */ `\n  if (TID == 0) {\n    output[WORKGROUP_ID] = s_data[0];\n  }\n`\n\nconst first_pass_load_data = /* wgsl */ `\n  let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\n\n  // Load current element into shared memory\n  // Also load next element for comparison\n  let elm = select(0u, input[GID], GID < ELEMENT_COUNT);\n  let next = select(0u, input[GID + 1], GID < ELEMENT_COUNT-1);\n  s_data[TID] = elm;\n  workgroupBarrier();\n\n  s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\n`\n\nconst last_pass = (kernelMode: string) => /* wgsl */ `\n  let fullDispatchLength = arrayLength(&output);\n  let dispatchIndex = TID * 3;\n\n  if (dispatchIndex >= fullDispatchLength) {\n    return;\n  }\n\n  ${kernelMode == 'full' ? last_pass_full : last_pass_fast}\n`\n\n// If the fast check kernel is sorted and the data isn't already sorted, run the full check\nconst last_pass_fast = /* wgsl */ `\n  output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u);\n`\n\n// If the full check kernel is sorted, set the flag to 1 and skip radix sort passes\nconst last_pass_full = /* wgsl */ `\n  if (TID == 0 && s_data[0] == 0) {\n    is_sorted = 1u;\n  }\n\n  output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] != 0);\n`\nexport default checkSortSource;\n","import { findOptimalDispatchSize } from './utils';\nimport type { WorkgroupSize } from './utils';\nimport checkSortSource from './shaders/CheckSort';\nimport { AbstractKernel, type IAbstractKernelOptions } from './AbstractKernel';\n\ninterface ICheckSortKernelOptions extends IAbstractKernelOptions {\n  data: GPUBuffer;\n  result: GPUBuffer;\n  original: GPUBuffer;\n  isSorted: GPUBuffer;\n  start?: number;\n  mode?: 'full' | 'fast' | 'reset';\n}\n\nexport class CheckSortKernel extends AbstractKernel {\n  public start: number;\n\n  public mode: 'full' | 'fast' | 'reset';\n\n  private buffers: Record<string, GPUBuffer> = {};\n\n  public outputs: Array<GPUBuffer> = [];\n\n  /**\n   * CheckSortKernel - Performs a parralel reduction to check if an array is sorted.\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - The number of elements to check\n   * @param {WorkgroupSize} workgroupSize - The workgroup size in x and y dimensions\n   * @param {GPUBuffer} data - The buffer containing the data to check\n   * @param {GPUBuffer} result - The result dispatch size buffer\n   * @param {GPUBuffer} original - The original dispatch size buffer\n   * @param {GPUBuffer} isSorted - 1-element buffer to store whether the array is sorted\n   * @param {number} start - The index to start checking from\n   * @param {boolean} mode - The type of check sort kernel ('reset', 'fast', 'full')\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    data,\n    result,\n    original,\n    isSorted,\n    start = 0,\n    mode = 'full',\n  }: ICheckSortKernelOptions) {\n    super({ device, count, workgroupSize });\n    this.start = start;\n    this.mode = mode;\n\n    this.buffers = {\n      data,\n      result,\n      original,\n      isSorted,\n    };\n\n    this.createPassesRecursive(data, count);\n  }\n\n  // Find the best dispatch size for each pass to minimize unused workgroups\n  static findOptimalDispatchChain(device: GPUDevice, itemCount: number, workgroupSize: WorkgroupSize) {\n    const threadsPerWorkgroup = workgroupSize.x * workgroupSize.y;\n    const sizes = [];\n\n    do {\n      // Number of workgroups required to process all items\n      const targetWorkgroupCount = Math.ceil(itemCount / threadsPerWorkgroup);\n\n      // Optimal dispatch size and updated workgroup count\n      const dispatchSize = findOptimalDispatchSize(device, targetWorkgroupCount);\n\n      sizes.push(dispatchSize.x, dispatchSize.y, 1);\n      itemCount = targetWorkgroupCount;\n    } while (itemCount > 1);\n\n    return sizes;\n  }\n\n  createPassesRecursive(buffer: GPUBuffer, count: number, passIndex: number = 0) {\n    const workgroupCount = Math.ceil(count / this.threadsPerWorkgroup);\n\n    const isFirstPass = passIndex === 0;\n    const isLastPass = workgroupCount <= 1;\n\n    const label = `check-sort-${this.mode}-${passIndex}`;\n\n    const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\n      label: label,\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        // Last pass bindings\n        ...(isLastPass ? [{\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        }, {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType }\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: buffer },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outputBuffer },\n        },\n        // Last pass buffers\n        ...(isLastPass ? [{\n          binding: 2,\n          resource: { buffer: this.buffers.original },\n        }, {\n          binding: 3,\n          resource: { buffer: this.buffers.isSorted },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const elementCount = isFirstPass ? this.start + count : count;\n    const startElement = isFirstPass ? this.start : 0;\n\n    const checkSortPipeline = this.device.createComputePipeline({\n      layout: pipelineLayout,\n      compute: {\n        module: this.device.createShaderModule({\n          label: label,\n          code: checkSortSource(isFirstPass, isLastPass, this.mode),\n        }),\n        entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\n        constants: {\n          'ELEMENT_COUNT': elementCount,\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          ...(this.mode !== 'reset' && {\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'START_ELEMENT': startElement,\n          }),\n        },\n      },\n    });\n\n    this.outputs.push(outputBuffer);\n    this.pipelines.push({ pipeline: checkSortPipeline, bindGroup });\n\n    if (!isLastPass) {\n      this.createPassesRecursive(outputBuffer, workgroupCount, passIndex + 1);\n    }\n  }\n\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup }, i) => {\n      const dispatchIndirect = this.mode !== 'reset' && (this.mode === 'full' || i < this.pipelines.length - 1);\n\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (dispatchIndirect && dispatchSizeBuffer) {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      } else {\n        // Only the reset kernel and the last dispatch of the fast check kernel are constant to (1, 1, 1)\n        pass.dispatchWorkgroups(1, 1, 1);\n      }\n    });\n  }\n}\n","export default `\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  let elm = select(input[GID], 0u, GID >= ELEMENT_COUNT);\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu; \n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  if (GID < ELEMENT_COUNT) {\n    // Store local prefix sum to global memory\n    local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\n  }\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  var elm: u32 = 0u;\n  var val: u32 = 0u;\n  if (GID < ELEMENT_COUNT) {\n    elm = input[GID];\n    val = values[GID];\n  }\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu; \n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  let prefix_sum = bit_prefix_sums[extract_bits];   \n\n  // Scan bit prefix sums\n  if (TID == LAST_THREAD) {\n    var sum: u32 = 0u;\n    bit_prefix_sums[extract_bits] += 1u;\n\n    for (var i: u32 = 0u; i < 4u; i++) {\n      s_prefix_sum_scan[i] = sum;\n      sum += bit_prefix_sums[i];\n    }\n  }\n  workgroupBarrier();\n\n  if (GID < ELEMENT_COUNT) {\n    // Compute new position\n    let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\n\n    // Shuffle elements locally\n    input[WID + new_pos] = elm;\n    values[WID + new_pos] = val;\n    local_prefix_sums[WID + new_pos] = prefix_sum;\n  }\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort_reorder(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) { \n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  if (GID >= ELEMENT_COUNT) { return; }\n\n  let k = inputKeys[GID];\n  let v = inputValues[GID];\n\n  let local_prefix = local_prefix_sum[GID];\n\n  // Calculate new position\n  let extract_bits = (k >> CURRENT_BIT) & 0x3u;\n  let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\n  let sorted_position = prefix_block_sum[pid] + local_prefix;\n\n  outputKeys[sorted_position] = k;\n  outputValues[sorted_position] = v;\n}\n`;\n\n","import { PrefixSumKernel } from './PrefixSumKernel';\nimport { CheckSortKernel } from './CheckSortKernel';\nimport { createBufferFromData, findOptimalDispatchSize } from './utils';\nimport type {WorkgroupSize, DispatchSize } from './utils';\nimport radixSortSource from './shaders/RadixSort';\nimport radixSortSource_LocalShuffle from './shaders/optimizations/RadixSortLocalShuffle';\nimport reorderSource from './shaders/RadixSortReorder';\nimport { AbstractKernel } from './AbstractKernel';\n\ninterface IRadixSortKernelOptions {\n  device: GPUDevice;\n  count: number;\n  workgroupSize: WorkgroupSize;\n  texture?: GPUTexture;\n  keys?: GPUBuffer;\n  values?: GPUBuffer;\n  bitCount: number;\n  checkOrder?: boolean;\n  localShuffle?: boolean;\n  avoidBankConflicts?: boolean;\n}\n\ninterface IDispatchData {\n  initialDispatch: Array<number>;\n  dispatchSizesFull: Array<number>;\n  checkSortFastCount: number;\n  checkSortFullCount: number;\n  startFull: number;\n}\n\nexport class RadixSortKernel extends AbstractKernel {\n  public bitCount: number;\n\n  public checkOrder: boolean = false;\n\n  public localShuffle: boolean = false;\n\n  public avoidBankConflicts: boolean = false;\n\n  private prefixBlockWorkgroupCount: number;\n\n  private hasValues: boolean;\n\n  private dispatchSize: DispatchSize = {\n    x: 1,\n    y: 1,\n  };\n\n  private dispatchOffsets = {\n    radixSort: 0,\n    checkSortFast: 3 * 4,\n    prefixSum: 6 * 4\n  };\n\n  private initialDispatch: Array<number> = [];\n\n  private kernels: {\n    prefixSum?: PrefixSumKernel;\n    checkSort?: {\n      reset: CheckSortKernel;\n      fast: CheckSortKernel;\n      full: CheckSortKernel;\n    };\n  } = {};\n\n  public buffers: Record<string, GPUBuffer | undefined> = {};\n\n  public texture?: GPUTexture;\n\n  /**\n   * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\n   * Note: The buffers are sorted in-place.\n   * \n   * Based on \"Fast 4-way parallel radix sorting on GPUs\"\n   * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - Number of elements to sort\n   * @param {WorkgroupSize} workgroupSize - Workgroup size in x and y dimensions. (x * y) must be a power of two\n   * @param {GPUTexture} texture - storage texture 2d rg32uint containing the pairs or [key, value] stored in a pixel\n   * @param {GPUBuffer} keys - Buffer containing the keys to sort\n   * @param {GPUBuffer} values - (optional) Buffer containing the associated values\n   * @param {number} bitCount - Number of bits per element (default: 32)\n   * @param {boolean} checkOrder - Enable \"order checking\" optimization. Can improve performance if the data needs to be sorted in real-time and doesn't change much. (default: false)\n   * @param {boolean} localShuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\n   * @param {boolean} avoidBankConflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    texture,\n    keys,\n    values,\n    bitCount = 32,\n    checkOrder = false,\n    localShuffle = false,\n    avoidBankConflicts = false,\n  }: IRadixSortKernelOptions) {\n    super({ device, count, workgroupSize });\n    if (!device) throw new Error('No device provided');\n    if (!keys && !texture) throw new Error('No keys buffer or texture provided');\n    if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter');\n    if (!Number.isInteger(bitCount) || bitCount <= 0 || bitCount > 32) throw new Error(`Invalid bitCount parameter: ${bitCount}`);\n    if (!Number.isInteger(workgroupSize.x) || !Number.isInteger(workgroupSize.y)) throw new Error('Invalid workgroupSize parameter');\n    if (bitCount % 4 != 0) throw new Error('bitCount must be a multiple of 4');\n\n    this.bitCount = bitCount;\n    this.checkOrder = checkOrder;\n    this.localShuffle = localShuffle;\n    this.avoidBankConflicts = avoidBankConflicts;\n\n    this.prefixBlockWorkgroupCount = 4 * this.workgroupCount;\n\n    this.hasValues = !!values || !!texture; // Is the values buffer or input texture provided ?\n\n    this.texture = texture;\n    this.buffers = { keys, values }; // GPUBuffers\n\n    // Create shader modules from wgsl code\n    this.createShaderModules();\n\n    // Create multi-pass pipelines\n    this.createPipelines();\n  }\n\n  private createShaderModules() {\n    // Remove every occurence of \"values\" in the shader code if values buffer is not provided\n    const removeValues = (source: string) => source\n      .split('\\n')\n      .filter((line) => !line.toLowerCase().includes('values'))\n      .join('\\n')\n    ;\n\n    const blockSumSource = this.localShuffle ? radixSortSource_LocalShuffle : radixSortSource;\n\n    this.shaderModules = {\n      blockSum: this.device.createShaderModule({\n        label: 'radix-sort-block-sum',\n        code: this.hasValues ? blockSumSource : removeValues(blockSumSource),\n      }),\n      reorder: this.device.createShaderModule({\n        label: 'radix-sort-reorder',\n        code: this.hasValues ? reorderSource : removeValues(reorderSource),\n      }),\n    };\n  }\n\n  private createPipelines() {\n    // Block prefix sum kernel\n    this.createPrefixSumKernel();\n\n    // Indirect dispatch buffers\n    const dispatchData = this.calculateDispatchSizes();\n\n    // GPU buffers\n    this.createBuffers(dispatchData);\n\n    // Check sort kernels\n    this.createCheckSortKernels(dispatchData);\n\n    // Radix sort passes for every 2 bits\n    for (let bit = 0; bit < this.bitCount; bit += 2) {\n      // Swap buffers every pass\n      const even = (bit % 4 == 0);\n      const inKeys = even ? this.buffers.keys : this.buffers.tmpKeys;\n      const inValues = even ? this.buffers.values : this.buffers.tmpValues;\n      const outKeys = even ? this.buffers.tmpKeys : this.buffers.keys;\n      const outValues = even ? this.buffers.tmpValues : this.buffers.values;\n\n      // Compute local prefix sums and block sums\n      const blockSumPipeline = this.createBlockSumPipeline(inKeys!, inValues!, bit);\n\n      // Reorder keys and values\n      const reorderPipeline = this.createReorderPipeline(inKeys!, inValues!, outKeys!, outValues!, bit);\n\n      this.pipelines.push(blockSumPipeline, reorderPipeline);\n    }\n  }\n\n  private createPrefixSumKernel() {\n    // Prefix Block Sum buffer (4 element per workgroup)\n    const prefixBlockSumBuffer = this.device.createBuffer({\n      label: 'radix-sort-prefix-block-sum',\n      size: this.prefixBlockWorkgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create block prefix sum kernel\n    const prefixSumKernel = new PrefixSumKernel({\n      device: this.device,\n      data: prefixBlockSumBuffer,\n      count: this.prefixBlockWorkgroupCount,\n      workgroupSize: this.workgroupSize,\n      avoidBankConflicts: this.avoidBankConflicts,\n    });\n\n    this.kernels.prefixSum = prefixSumKernel;\n    this.buffers.prefixBlockSum = prefixBlockSumBuffer;\n  }\n\n  private calculateDispatchSizes(): IDispatchData {\n    // Radix sort dispatch size\n    const dispatchSize = findOptimalDispatchSize(this.device, this.workgroupCount);\n\n    // Prefix sum dispatch sizes\n    const prefixSumDispatchSize = this.kernels.prefixSum!.getDispatchChain();\n\n    // Check sort element count (fast/full)\n    const checkSortFastCount = Math.min(this.count, this.threadsPerWorkgroup * 4);\n    const checkSortFullCount = this.count - checkSortFastCount;\n    const startFull = checkSortFastCount - 1;\n\n    // Check sort dispatch sizes\n    const dispatchSizesFast = CheckSortKernel.findOptimalDispatchChain(this.device, checkSortFastCount, this.workgroupSize);\n    const dispatchSizesFull = CheckSortKernel.findOptimalDispatchChain(this.device, checkSortFullCount, this.workgroupSize);\n\n    // Initial dispatch sizes\n    const initialDispatch = [\n      dispatchSize.x, dispatchSize.y, 1, // Radix Sort + Reorder\n      ...dispatchSizesFast.slice(0, 3),  // Check sort fast\n      ...prefixSumDispatchSize,          // Prefix Sum\n    ];\n\n    // Dispatch offsets in main buffer\n    this.dispatchOffsets = {\n      radixSort: 0,\n      checkSortFast: 3 * 4,\n      prefixSum: 6 * 4,\n    };\n\n    this.dispatchSize = dispatchSize;\n    this.initialDispatch = initialDispatch;\n\n    return {\n      initialDispatch,\n      dispatchSizesFull,\n      checkSortFastCount,\n      checkSortFullCount,\n      startFull,\n    };\n  }\n\n  private createBuffers(dispatchData: IDispatchData) {\n    // Keys and values double buffering\n    const tmpKeysBuffer = this.device.createBuffer({\n      label: 'radix-sort-tmp-keys',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const tmpValuesBuffer = !this.hasValues ? undefined : this.device.createBuffer({\n      label: 'radix-sort-tmp-values',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Local Prefix Sum buffer (1 element per item)\n    const localPrefixSumBuffer = this.device.createBuffer({\n      label: 'radix-sort-local-prefix-sum',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    this.buffers.tmpKeys = tmpKeysBuffer;\n    this.buffers.tmpValues = tmpValuesBuffer;\n    this.buffers.localPrefixSum = localPrefixSumBuffer;\n\n    // Only create indirect dispatch buffers when checkOrder optimization is enabled\n    if (!this.checkOrder) {\n      return;\n    }\n\n    // Dispatch sizes (radix sort, check sort, prefix sum)\n    const dispatchBuffer = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    const originalDispatchBuffer = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size-original',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Dispatch sizes (full sort)\n    const checkSortFullDispatchBuffer = createBufferFromData({\n      label: 'check-sort-full-dispatch-size',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    const checkSortFullOriginalDispatchBuffer = createBufferFromData({\n      label: 'check-sort-full-dispatch-size-original',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Flag to tell if the data is sorted\n    const isSortedBuffer = createBufferFromData({\n      label: 'is-sorted',\n      device: this.device,\n      data: [0],\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    this.buffers.dispatchSize = dispatchBuffer;\n    this.buffers.originalDispatchSize = originalDispatchBuffer;\n    this.buffers.checkSortFullDispatchSize = checkSortFullDispatchBuffer;\n    this.buffers.originalCheckSortFullDispatchSize = checkSortFullOriginalDispatchBuffer;\n    this.buffers.isSorted = isSortedBuffer;\n  }\n\n  private createCheckSortKernels(checkSortPartitionData: IDispatchData) {\n    if (!this.checkOrder) {\n      return;\n    }\n\n    const { checkSortFastCount, checkSortFullCount, startFull } = checkSortPartitionData\n\n    // Create the full pass\n    const checkSortFull = new CheckSortKernel({\n      mode: 'full',\n      device: this.device,\n      data: this.buffers.keys!,\n      result: this.buffers.dispatchSize!,\n      original: this.buffers.originalDispatchSize!,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFullCount,\n      start: startFull,\n      workgroupSize: this.workgroupSize,\n    });\n\n    // Create the fast pass\n    const checkSortFast = new CheckSortKernel({\n      mode: 'fast',\n      device: this.device,\n      data: this.buffers.keys!,\n      result: this.buffers.checkSortFullDispatchSize!,\n      original: this.buffers.originalCheckSortFullDispatchSize!,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFastCount,\n      workgroupSize: this.workgroupSize,\n    });\n\n    const initialDispatchElementCount = this.initialDispatch.length / 3;\n\n    if (checkSortFast.threadsPerWorkgroup < checkSortFull.pipelines.length || checkSortFull.threadsPerWorkgroup < initialDispatchElementCount) {\n      console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`);\n      this.checkOrder = false;\n      return;\n    }\n\n    // Create the reset pass\n    const checkSortReset = new CheckSortKernel({\n      mode: 'reset',\n      device: this.device,\n      data: this.buffers.keys!,\n      original: this.buffers.originalDispatchSize!,\n      result: this.buffers.dispatchSize!,\n      isSorted: this.buffers.isSorted!,\n      count: initialDispatchElementCount,\n      workgroupSize: findOptimalDispatchSize(this.device, initialDispatchElementCount),\n    });\n\n    this.kernels.checkSort = {\n      reset: checkSortReset,\n      fast: checkSortFast,\n      full: checkSortFull,\n    };\n  }\n\n  private createBlockSumPipeline(inKeys: GPUBuffer, inValues: GPUBuffer, bit: number) {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-block-sum',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type: this.localShuffle\n              ? 'storage' as GPUBufferBindingType\n              : 'read-only-storage' as GPUBufferBindingType,\n          }\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inKeys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: this.buffers.localPrefixSum! },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.prefixBlockSum! },\n        },\n        // \"Local shuffle\" optimization needs access to the values buffer\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          resource: { buffer: inValues }\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const blockSumPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-block-sum',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.blockSum,\n        entryPoint: 'radix_sort',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: blockSumPipeline,\n      bindGroup,\n    };\n  }\n\n  createReorderPipeline(inKeys: GPUBuffer, inValues: GPUBuffer, outKeys: GPUBuffer, outValues: GPUBuffer, bit: number) {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-reorder',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n          },\n          {\n            binding: 5,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'storage' as GPUBufferBindingType },\n          },\n        ] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inKeys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outKeys },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.localPrefixSum! },\n        },\n        {\n          binding: 3,\n          resource: { buffer: this.buffers.prefixBlockSum! },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            resource: { buffer: inValues },\n          },\n          {\n            binding: 5,\n            resource: { buffer: outValues },\n          },\n        ] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const reorderPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-reorder',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.reorder,\n        entryPoint: 'radix_sort_reorder',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: reorderPipeline,\n      bindGroup,\n    };\n  }\n\n  /**\n   * Encode all pipelines into the current pass\n   * \n   * @param {GPUComputePassEncoder} pass \n   */\n  dispatch(pass: GPUComputePassEncoder) {\n    if (!this.checkOrder) {\n      this.#dispatchPipelines(pass);\n    } else {\n      this.#dispatchPipelinesIndirect(pass);\n    }\n  }\n\n  /**\n   * Dispatch workgroups from CPU args\n   */\n  #dispatchPipelines(pass: GPUComputePassEncoder) {\n    for (let i = 0; i < this.bitCount / 2; i += 1) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n    }\n  }\n\n  /**\n   * Dispatch workgroups from indirect GPU buffers (used when checkOrder is enabled)\n   */\n  #dispatchPipelinesIndirect(pass: GPUComputePassEncoder) {\n    // Reset the `dispatch` and `is_sorted` buffers\n    this.kernels.checkSort!.reset.dispatch(pass);\n\n    for (let i = 0; i < this.bitCount / 2; i++) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      if (i % 2 == 0) {\n        // Check if the data is sorted every 2 passes\n        this.kernels.checkSort!.fast.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.checkSortFast);\n        this.kernels.checkSort!.full.dispatch(pass, this.buffers.checkSortFullDispatchSize);\n      }\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefixSum);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n    }\n  }\n}\n"],"names":["findOptimalDispatchSize","device","workgroupCount","dispatchSize","x","y","createBufferFromData","label","data","usage","dispatchSizes","prefixSumSource","prefixSumSourceNoBankConflict","AbstractKernel","count","workgroupSize","PrefixSumKernel","avoidBankConflicts","blockSumBuffer","bindGroupLayout","bindGroup","pipelineLayout","scanPipeline","blockSumPipeline","p","pass","dispatchSizeBuffer","offset","pipeline","i","checkSortSource","isFirstPass","isLastPass","kernelMode","first_pass_load_data","last_pass","write_reduction_result","last_pass_full","last_pass_fast","CheckSortKernel","result","original","isSorted","start","mode","itemCount","threadsPerWorkgroup","sizes","targetWorkgroupCount","buffer","passIndex","outputBuffer","elementCount","startElement","checkSortPipeline","dispatchIndirect","radixSortSource","radixSortSource_LocalShuffle","reorderSource","RadixSortKernel","texture","keys","values","bitCount","checkOrder","localShuffle","removeValues","source","line","blockSumSource","dispatchData","bit","even","inKeys","inValues","outKeys","outValues","reorderPipeline","prefixBlockSumBuffer","prefixSumKernel","prefixSumDispatchSize","checkSortFastCount","checkSortFullCount","startFull","dispatchSizesFast","dispatchSizesFull","initialDispatch","tmpKeysBuffer","tmpValuesBuffer","localPrefixSumBuffer","dispatchBuffer","originalDispatchBuffer","checkSortFullDispatchBuffer","checkSortFullOriginalDispatchBuffer","isSortedBuffer","checkSortPartitionData","checkSortFull","checkSortFast","initialDispatchElementCount","checkSortReset","#dispatchPipelinesIndirect","#dispatchPipelines"],"mappings":"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"}