{"version":3,"file":"radix-sort.es.js","sources":["../src/kernels/AbstractKernel.ts","../src/utils.ts","../src/shaders/PrefixSum.ts","../src/shaders/optimizations/PrefixSumNoBankConflict.ts","../src/kernels/PrefixSumKernel.ts","../src/kernels/check-sort/AbstractCheckSortKernel.ts","../src/kernels/radix-sort/AbstractRadixSortKernel.ts","../src/shaders/RadixSort.ts","../src/shaders/optimizations/RadixSortLocalShuffle.ts","../src/shaders/RadixSortReorder.ts","../src/shaders/CheckSort.ts","../src/kernels/check-sort/CheckSortBufferKernel.ts","../src/kernels/radix-sort/RadixSortBufferKernel.ts","../src/kernels/check-sort/CheckSortTextureKernel.ts","../src/kernels/radix-sort/RadixSortTextureKernel.ts"],"sourcesContent":["import type { DispatchSize, WorkgroupSize } from '../utils';\n\nexport interface AbstractKernelOptions {\n  device: GPUDevice;\n  count: number;\n  workgroupSize?: WorkgroupSize;\n}\n\nexport interface KernelPipelineDefinition {\n  pipeline: GPUComputePipeline;\n  bindGroup: GPUBindGroup;\n  dispatchSize?: DispatchSize;\n}\n\nexport abstract class AbstractKernel {\n  public options: AbstractKernelOptions;\n\n  declare device: GPUDevice;\n\n  declare count: number;\n\n  public workgroupSize: WorkgroupSize = {\n    x: 16,\n    y: 16,\n  };\n\n  public pipelines: Array<KernelPipelineDefinition> = [];\n\n  protected shaderModules: Record<string, GPUShaderModule> = {};\n\n  constructor(options: AbstractKernelOptions) {\n    this.options = options;\n    Object.keys(options).forEach((key) => {\n      Object.defineProperty(this, key, {\n        get: () => this.options[key as keyof AbstractKernelOptions],\n        set: (val) => { this.options[key as keyof AbstractKernelOptions] = val; },\n      });\n    });\n  }\n\n  get workgroupCount(): number {\n    return Math.ceil(this.count / this.threadsPerWorkgroup);\n  }\n\n  get threadsPerWorkgroup(): number {\n    return this.workgroupSize.x * this.workgroupSize.y\n  }\n\n  get itemsPerWorkgroup(): number {\n    return 2 * this.threadsPerWorkgroup;\n  }\n\n  abstract dispatch(\n    passEncoder: GPUComputePassEncoder,\n    dispatchSizeBuffer?: GPUBuffer,\n    offset?: number,\n  ): void;\n}\n","export type WorkgroupSize = {\n  x: number;\n  y: number;\n}\n\nexport type DispatchSize = WorkgroupSize;\n\nexport function findOptimalDispatchSize(device: GPUDevice, workgroupCount: number) {\n  const dispatchSize = { \n    x: workgroupCount, \n    y: 1,\n  };\n\n  if (workgroupCount > device.limits.maxComputeWorkgroupsPerDimension) {\n    const x = Math.floor(Math.sqrt(workgroupCount));\n    const y = Math.ceil(workgroupCount / x);\n\n    dispatchSize.x = x;\n    dispatchSize.y = y;\n  }\n\n  return dispatchSize;\n}\n\nexport function createBufferFromData({ device, label, data, usage = 0 }: {\n  device: GPUDevice,\n  label: string,\n  data: number[],\n  usage: number,\n}) {\n  const dispatchSizes = device.createBuffer({\n    label,\n    usage,\n    size: data.length * 4,\n    mappedAtCreation: true,\n  });\n\n  const dispatchData = new Uint32Array(dispatchSizes.getMappedRange());\n  dispatchData.set(data);\n  dispatchSizes.unmap();\n\n  return dispatchSizes;\n}\n\nexport function bufferToTexture(device: GPUDevice, buffer: GPUBuffer): GPUTexture {\n  const TEXTURE_WIDTH = Math.min(8192, buffer.size);\n  const TEXTURE_HEIGHT = Math.ceil((buffer.size) / TEXTURE_WIDTH);\n\n  const texture = device.createTexture({\n    size: {\n      width: TEXTURE_WIDTH,\n      height: TEXTURE_HEIGHT,\n    },\n    format: 'r32uint',\n    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n  });\n  const command = device.createCommandEncoder();\n  command.copyBufferToTexture({ buffer }, { texture }, [texture.width, texture.height, texture.depthOrArrayLayers]);\n  device.queue.submit([command.finish()]);\n\n  return texture;\n}\n\nexport const removeValues = (source: string) => source\n  .split('\\n')\n  .filter((line) => !line.toLowerCase().includes('values'))\n  .join('\\n')\n;\n","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  temp[ELM_TID]      = select(items[ELM_GID], 0u, ELM_GID >= ELEMENT_COUNT);\n  temp[ELM_TID + 1u] = select(items[ELM_GID + 1u], 0u, ELM_GID + 1u >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n    // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    let last_offset = ITEMS_PER_WORKGROUP - 1u;\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (ELM_GID >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID] = temp[ELM_TID];\n\n  if (ELM_GID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID + 1u] = temp[ELM_TID + 1u];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nconst NUM_BANKS: u32 = 32u;\nconst LOG_NUM_BANKS: u32 = 5u;\n\nfn get_offset(offset: u32) -> u32 {\n  // return offset >> LOG_NUM_BANKS; // Conflict-free\n  return (offset >> NUM_BANKS) + (offset >> (2u * LOG_NUM_BANKS)); // Zero bank conflict\n}\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  let ai: u32 = TID;\n  let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1u);\n  let s_ai = ai + get_offset(ai);\n  let s_bi = bi + get_offset(bi);\n  let g_ai = ai + WID * 2u;\n  let g_bi = bi + WID * 2u;\n  temp[s_ai] = select(items[g_ai], 0u, g_ai >= ELEMENT_COUNT);\n  temp[s_bi] = select(items[g_bi], 0u, g_bi >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n  // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    var last_offset = ITEMS_PER_WORKGROUP - 1u;\n    last_offset += get_offset(last_offset);\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (g_ai < ELEMENT_COUNT) {\n    items[g_ai] = temp[s_ai];\n  }\n  if (g_bi < ELEMENT_COUNT) {\n    items[g_bi] = temp[s_bi];\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","import { findOptimalDispatchSize } from '../utils';\nimport prefixSumSource from '../shaders/PrefixSum';\nimport prefixSumSourceNoBankConflict from '../shaders/optimizations/PrefixSumNoBankConflict';\nimport { AbstractKernel, type AbstractKernelOptions } from './AbstractKernel';\n\ninterface IPrefixSumKernelOptions extends AbstractKernelOptions {\n  data: GPUBuffer;\n  avoidBankConflicts?: boolean;\n}\n\nexport class PrefixSumKernel extends AbstractKernel {\n  /**\n   * Perform a parallel prefix sum on the given data buffer\n   * \n   * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\n   * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - Max number of elements to process\n   * @param {WorkgroupSize} workgroupSize - Workgroup size in x and y dimensions. (x * y) must be a power of two\n   * @param {GPUBuffer} data - Buffer containing the data to process\n   * @param {boolean} avoidBankConflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    data,\n    avoidBankConflicts = false\n  }: IPrefixSumKernelOptions) {\n    super({ device, count, workgroupSize });\n\n    if (Math.log2(this.threadsPerWorkgroup) % 1 !== 0) {\n      throw new Error(`workgroupSize.x * workgroupSize.y must be a power of two. (current: ${this.threadsPerWorkgroup})`);\n    }\n\n    this.shaderModules.prefixSum = this.device.createShaderModule({\n      label: 'prefix-sum',\n      code: avoidBankConflicts ? prefixSumSourceNoBankConflict : prefixSumSource,\n    })\n\n    this.createPassRecursive(data, count);\n  }\n\n  createPassRecursive(data: GPUBuffer, count: number) {\n    // Find best dispatch x and y dimensions to minimize unused threads\n    const workgroupCount = Math.ceil(count / this.itemsPerWorkgroup);\n    const dispatchSize = findOptimalDispatchSize(this.device, workgroupCount);\n\n    // Create buffer for block sums\n    const blockSumBuffer = this.device.createBuffer({\n      label: 'prefix-sum-block-sum',\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create bind group and pipeline layout\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      label: 'prefix-sum-bind-group',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: data },\n        },\n        {\n          binding: 1,\n          resource: { buffer: blockSumBuffer },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [ bindGroupLayout ],\n    });\n\n    // Per-workgroup (block) prefix sum\n    const scanPipeline = this.device.createComputePipeline({\n      label: 'prefix-sum-scan-pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.prefixSum,\n        entryPoint: 'reduce_downsweep',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ITEMS_PER_WORKGROUP': this.itemsPerWorkgroup,\n          'ELEMENT_COUNT': count,\n        },\n      },\n    });\n\n    this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize });\n\n    if (workgroupCount > 1) {\n      // Prefix sum on block sums\n      this.createPassRecursive(blockSumBuffer, workgroupCount);\n\n      // Add block sums to local prefix sums\n      const blockSumPipeline = this.device.createComputePipeline({\n        label: 'prefix-sum-add-block-pipeline',\n        layout: pipelineLayout,\n        compute: {\n          module: this.shaderModules.prefixSum,\n          entryPoint: 'add_block_sums',\n          constants: {\n            'WORKGROUP_SIZE_X': this.workgroupSize.x,\n            'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'ELEMENT_COUNT': count,\n          },\n        },\n      });\n\n      this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize });\n    }\n  }\n\n  getDispatchChain() {\n    return this.pipelines.flatMap((p) => [ p.dispatchSize!.x, p.dispatchSize!.y, 1 ]);\n  }\n\n  /**\n   * Encode the prefix sum pipeline into the current pass.\n   * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\n   *\n   * @param {GPUComputePassEncoder} pass\n   * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\n   * @param {number} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\n   */\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup, dispatchSize }, i) => {\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (!dispatchSizeBuffer) {\n        pass.dispatchWorkgroups(dispatchSize!.x, dispatchSize!.y, 1);\n      } else {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      }\n    });\n  }\n}\n","import { AbstractKernel, type AbstractKernelOptions } from '../AbstractKernel';\nimport { findOptimalDispatchSize, WorkgroupSize } from '../../utils';\n\nexport interface AbstractCheckSortKernelOptions<T> extends AbstractKernelOptions {\n  data: T;\n  result: GPUBuffer;\n  original: GPUBuffer;\n  isSorted: GPUBuffer;\n  start?: number;\n  mode?: 'full' | 'fast' | 'reset';\n}\n\nexport abstract class AbstractCheckSortKernel<T> extends AbstractKernel {\n  declare start: number;\n\n  declare mode: 'full' | 'fast' | 'reset';\n\n  public buffers: Record<string, GPUBuffer> = {};\n\n  constructor(options: AbstractCheckSortKernelOptions<T>) {\n    super(options);\n    this.start = options.start ?? 0;\n    this.mode = options.mode ?? 'full';\n\n    this.buffers.result = options.result;\n    this.buffers.original = options.original;\n    this.buffers.isSorted = options.isSorted;\n  }\n\n  // Find the best dispatch size for each pass to minimize unused workgroups\n  static findOptimalDispatchChain(device: GPUDevice, itemCount: number, workgroupSize: WorkgroupSize) {\n    const threadsPerWorkgroup = workgroupSize.x * workgroupSize.y;\n    const sizes = [];\n\n    do {\n      // Number of workgroups required to process all items\n      const targetWorkgroupCount = Math.ceil(itemCount / threadsPerWorkgroup);\n\n      // Optimal dispatch size and updated workgroup count\n      const dispatchSize = findOptimalDispatchSize(device, targetWorkgroupCount);\n\n      sizes.push(dispatchSize.x, dispatchSize.y, 1);\n      itemCount = targetWorkgroupCount;\n    } while (itemCount > 1);\n\n    return sizes;\n  }\n\n  protected abstract createPassesRecursive(data: T, count: number, passIndex: number): void;\n\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup }, i) => {\n      const dispatchIndirect = this.mode !== 'reset' && (this.mode === 'full' || i < this.pipelines.length - 1);\n\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (dispatchIndirect && dispatchSizeBuffer) {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      } else {\n        // Only the reset kernel and the last dispatch of the fast check kernel are constant to (1, 1, 1)\n        pass.dispatchWorkgroups(1, 1, 1);\n      }\n    });\n  }\n}\n","import { AbstractKernel, type KernelPipelineDefinition, type AbstractKernelOptions } from '../AbstractKernel';\nimport { PrefixSumKernel } from '../PrefixSumKernel';\nimport { createBufferFromData, findOptimalDispatchSize, type DispatchSize } from '../../utils';\nimport { AbstractCheckSortKernel } from '../check-sort/AbstractCheckSortKernel';\n\nexport interface DispatchData {\n  initialDispatch: Array<number>;\n  dispatchSizesFull: Array<number>;\n  checkSortFastCount: number;\n  checkSortFullCount: number;\n  startFull: number;\n}\n\nexport interface AbstractRadixSortKernelOptions<T> extends AbstractKernelOptions {\n  data: T;\n  bitCount?: number;\n  checkOrder?: boolean;\n  avoidBankConflicts?: boolean;\n}\n\nexport abstract class AbstractRadixSortKernel<T> extends AbstractKernel {\n  declare data: T;\n\n  declare bitCount: number;\n\n  declare checkOrder: boolean;\n\n  declare avoidBankConflicts: boolean;\n\n  public buffers: Record<string, GPUBuffer> = {};\n\n  protected kernels: {\n    prefixSum?: PrefixSumKernel;\n    checkSortReset?: AbstractCheckSortKernel<T>;\n    checkSortFast?: AbstractCheckSortKernel<T>;\n    checkSortFull?: AbstractCheckSortKernel<T>;\n  } = {};\n\n  private dispatchSize: DispatchSize = {\n    x: 1,\n    y: 1,\n  };\n\n  private dispatchOffsets = {\n    radixSort: 0,\n    checkSortFast: 3 * 4,\n    prefixSum: 6 * 4\n  };\n\n  protected initialDispatch: Array<number> = [];\n\n  constructor(options: AbstractRadixSortKernelOptions<T>) {\n    super(options);\n    this.bitCount = options.bitCount ?? 32;\n    this.checkOrder = options.checkOrder ?? false;\n    this.avoidBankConflicts = options.avoidBankConflicts ?? false;\n  }\n\n  get prefixBlockWorkgroupCount(): number {\n    return 4 * this.workgroupCount;\n  }\n\n  abstract get hasValues(): boolean;\n\n  protected abstract get blockSumSource(): string;\n\n  protected abstract get reorderSource(): string;\n\n  protected createShaderModules() {\n    this.shaderModules.blockSum = this.device.createShaderModule({\n      label: 'radix-sort-block-sum',\n      code: this.blockSumSource,\n    });\n    this.shaderModules.reorder = this.device.createShaderModule({\n      label: 'radix-sort-reorder',\n      code: this.reorderSource,\n    });\n  }\n\n  protected createPipelines() {\n    // Block prefix sum kernel\n    this.#createPrefixSumKernel();\n\n    // Indirect dispatch buffers\n    const dispatchData = this.#calculateDispatchSizes();\n\n    // GPU resources (buffers / textures)\n    this.createResources();\n    this.#createCheckSortBuffers(dispatchData);\n\n    this.createCheckSortKernels(dispatchData);\n\n    // Radix sort passes for every 2 bits\n    for (let bit = 0; bit < this.bitCount; bit += 2) {\n      // Swap buffers every pass\n      const even = (bit % 4 === 0);\n      const inData = this.getPassInData(even);\n      const outData = this.getPassOutData(even);\n\n      // Compute local prefix sums and block sums\n      const blockSumPipeline = this.createBlockSumPipeline(inData, bit);\n\n      // Reorder keys and values\n      const reorderPipeline = this.createReorderPipeline(inData, outData, bit);\n\n      this.pipelines.push(blockSumPipeline, reorderPipeline);\n    }\n  }\n\n  #createPrefixSumKernel() {\n    // Prefix Block Sum buffer (4 element per workgroup)\n    const prefixBlockSumBuffer = this.device.createBuffer({\n      label: 'radix-sort-prefix-block-sum',\n      size: this.prefixBlockWorkgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create block prefix sum kernel\n    const prefixSumKernel = new PrefixSumKernel({\n      device: this.device,\n      data: prefixBlockSumBuffer,\n      count: this.prefixBlockWorkgroupCount,\n      workgroupSize: this.workgroupSize,\n      avoidBankConflicts: this.avoidBankConflicts,\n    });\n\n    this.kernels.prefixSum = prefixSumKernel;\n    this.buffers.prefixBlockSum = prefixBlockSumBuffer;\n  }\n\n  #calculateDispatchSizes(): DispatchData {\n    // Radix sort dispatch size\n    const dispatchSize = findOptimalDispatchSize(this.device, this.workgroupCount);\n\n    // Prefix sum dispatch sizes\n    const prefixSumDispatchSize = this.kernels.prefixSum!.getDispatchChain();\n\n    // Check sort element count (fast/full)\n    const checkSortFastCount = Math.min(this.count, this.threadsPerWorkgroup * 4);\n    const checkSortFullCount = this.count - checkSortFastCount;\n    const startFull = checkSortFastCount - 1;\n\n    // Check sort dispatch sizes\n    const dispatchSizesFast = AbstractCheckSortKernel.findOptimalDispatchChain(this.device, checkSortFastCount, this.workgroupSize);\n    const dispatchSizesFull = AbstractCheckSortKernel.findOptimalDispatchChain(this.device, checkSortFullCount, this.workgroupSize);\n\n    // Initial dispatch sizes\n    const initialDispatch = [\n      dispatchSize.x, dispatchSize.y, 1, // Radix Sort + Reorder\n      ...dispatchSizesFast.slice(0, 3),  // Check sort fast\n      ...prefixSumDispatchSize,          // Prefix Sum\n    ];\n\n    this.dispatchSize = dispatchSize;\n    this.initialDispatch = initialDispatch;\n\n    return {\n      initialDispatch,\n      dispatchSizesFull,\n      checkSortFastCount,\n      checkSortFullCount,\n      startFull,\n    };\n  }\n\n  protected abstract createResources(): void;\n\n  protected abstract getPassInData(even: boolean): T;\n\n  protected abstract getPassOutData(even: boolean): T;\n\n  #createCheckSortBuffers(dispatchData: DispatchData) {\n    // Only create indirect dispatch buffers when checkOrder optimization is enabled\n    if (!this.checkOrder) {\n      return;\n    }\n\n    // Dispatch sizes (radix sort, check sort, prefix sum)\n    this.buffers.dispatchSize = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    this.buffers.originalDispatchSize = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size-original',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Dispatch sizes (full sort)\n    this.buffers.checkSortFullDispatchSize = createBufferFromData({\n      label: 'check-sort-full-dispatch-size',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    this.buffers.originalCheckSortFullDispatchSize = createBufferFromData({\n      label: 'check-sort-full-dispatch-size-original',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Flag to tell if the data is sorted\n    this.buffers.isSorted = createBufferFromData({\n      label: 'is-sorted',\n      device: this.device,\n      data: [0],\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n  }\n\n  protected abstract createCheckSortKernels(dispatchData: DispatchData): void;\n\n  protected abstract createBlockSumPipeline(inData: T, bit: number): KernelPipelineDefinition;\n\n  protected abstract createReorderPipeline(inData: T, outData: T, bit: number): KernelPipelineDefinition;\n\n  dispatch(pass: GPUComputePassEncoder) {\n    if (!this.checkOrder) {\n      this.#dispatchPipelines(pass);\n    } else {\n      this.#dispatchPipelinesIndirect(pass);\n    }\n  }\n\n  #dispatchPipelines(pass: GPUComputePassEncoder) {\n    for (let i = 0; i < this.bitCount / 2; i += 1) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n    }\n  }\n\n  #dispatchPipelinesIndirect(pass: GPUComputePassEncoder) {\n    // Reset the `dispatch` and `is_sorted` buffers\n    this.kernels.checkSortReset!.dispatch(pass);\n\n    for (let i = 0; i < this.bitCount / 2; i++) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      if (i % 2 == 0) {\n        // Check if the data is sorted every 2 passes\n        this.kernels.checkSortFast!.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.checkSortFast);\n        this.kernels.checkSortFull!.dispatch(pass, this.buffers.checkSortFullDispatchSize);\n      }\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefixSum);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n    }\n  }\n}\n","const radixSortSource = (dataType: 'buffer' | 'texture') => /* wgsl */ `\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(0) var<storage, read> input: array<u32>;\n      @group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n    `\n    : `\n      @group(0) @binding(0) var input: texture_storage_2d<rg32uint, read>;\n      @group(0) @binding(1) var local_prefix_sums: texture_storage_2d<r32uint, write>;\n    `\n}\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\n\nfn getInput(index: u32) -> u32 {\n  ${\n    dataType === 'buffer'\n      ? `return input[index];`\n      : `\n        let dimX = textureDimensions(input).r;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        return textureLoad(input, vec2<i32>(x, y)).x;\n      `\n  }\n}\n\nfn setLocalPrefixSum(index: u32, val: u32) {\n  ${\n    dataType === 'buffer'\n      ? 'local_prefix_sums[index] = val;'\n      : `\n        let dimX = textureDimensions(local_prefix_sums).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        textureStore(local_prefix_sums, vec2<i32>(x, y), vec4<u32>(val, 0u, 0u, 0u));\n      `\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  let elm = select(getInput(GID), 0u, GID >= ELEMENT_COUNT);\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu;\n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  if (GID < ELEMENT_COUNT) {\n    // Store local prefix sum to global memory\n    setLocalPrefixSum(GID, bit_prefix_sums[extract_bits]);\n  }\n}\n`;\n\nexport default radixSortSource;\n","export default `\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  var elm: u32 = 0u;\n  var val: u32 = 0u;\n  if (GID < ELEMENT_COUNT) {\n    elm = input[GID];\n    val = values[GID];\n  }\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu; \n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  let prefix_sum = bit_prefix_sums[extract_bits];   \n\n  // Scan bit prefix sums\n  if (TID == LAST_THREAD) {\n    var sum: u32 = 0u;\n    bit_prefix_sums[extract_bits] += 1u;\n\n    for (var i: u32 = 0u; i < 4u; i++) {\n      s_prefix_sum_scan[i] = sum;\n      sum += bit_prefix_sums[i];\n    }\n  }\n  workgroupBarrier();\n\n  if (GID < ELEMENT_COUNT) {\n    // Compute new position\n    let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\n\n    // Shuffle elements locally\n    input[WID + new_pos] = elm;\n    values[WID + new_pos] = val;\n    local_prefix_sums[WID + new_pos] = prefix_sum;\n  }\n}\n`;\n","const reorderSource = (dataType: 'buffer' | 'texture') => `\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\n      @group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\n      @group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\n    `\n    : `\n      @group(0) @binding(0) var input: texture_storage_2d<rg32uint, read>;\n      @group(0) @binding(1) var output: texture_storage_2d<rg32uint, write>;\n      @group(0) @binding(2) var local_prefix_sum: texture_storage_2d<r32uint, read_write>;\n    `\n}\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(4) var<storage, read> inputValues: array<u32>;\n      @group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\n    `\n    : ''\n}\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nfn getInput(index: u32) -> vec2<u32> {\n  ${\n    dataType === 'buffer'\n      ? `\n        let result: vec2<u32> = vec2<u32>(\n          inputKeys[index],\n          inputValues[index]\n        );\n        return result;\n      `\n      : `\n        let dimX = textureDimensions(input).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimY);\n        return textureLoad(input, vec2<i32>(x, y)).xy;\n      `\n  }\n}\n\nfn setOutput(index: u32, key: u32, val: u32) {\n  ${\n    dataType === 'buffer'\n      ? `\n        outputKeys[index] = key;\n        outputValues[index] = val;\n      `\n      : `\n        let dimX = textureDimensions(output).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        textureStore(output, vec2<i32>(x, y), vec4<u32>(key, val, 0u, 0u));\n      `\n  }\n}\n\nfn getLocalPrefixSum(index: u32) -> u32 {\n  ${\n    dataType === 'buffer'\n      ? 'return local_prefix_sum[index];'\n      : `\n        let dimX = textureDimensions(local_prefix_sum).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        return textureLoad(local_prefix_sum, vec2<i32>(x, y)).x;\n      `\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort_reorder(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  if (GID >= ELEMENT_COUNT) { return; }\n\n  let input = getInput(GID);\n\n  let local_prefix = getLocalPrefixSum(GID);\n\n  // Calculate new position\n  let extract_bits = (input.x >> CURRENT_BIT) & 0x3u;\n  let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\n  let sorted_position = prefix_block_sum[pid] + local_prefix;\n\n  setOutput(sorted_position, input.x, input.y);\n}\n`;\n\nexport default reorderSource;\n","const checkSortSource = (isFirstPass = false, isLastPass = false, kernelMode = 'full', dataType: 'buffer' | 'texture') => /* wgsl */ `\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(0) var<storage, read> input: array<u32>;\n      @group(0) @binding(1) var<storage, read_write> output: array<u32>;\n    `\n    : `\n      @group(0) @binding(0) var input: texture_storage_2d<rg32uint, read>;\n      @group(0) @binding(1) var output: texture_storage_2d<r32uint, write>;\n    `\n}\n@group(0) @binding(2) var<storage, read> original: array<u32>;\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\noverride START_ELEMENT: u32;\n\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\n\nfn getInput(index: u32) -> u32 {\n  ${\n    dataType === 'buffer'\n      ? 'return input[index];'\n      : `\n        let dimX = textureDimensions(input).r;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        return textureLoad(input, vec2<i32>(x, y)).x;\n      `\n  }\n}\n\nfn setOutput(index: u32, data: u32) {\n  ${\n    dataType === 'buffer'\n      ? 'output[index] = data;'\n      : `\n        let dimX = textureDimensions(output).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        textureStore(output, vec2<i32>(x, y), vec4<u32>(data, 0u, 0u, 0u));\n      `\n  }\n}\n\n// Reset dispatch buffer and is_sorted flag\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reset(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  if (TID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  if (TID == 0) {\n    is_sorted = 0u;\n  }\n\n  let ELM_ID = TID * 3;\n\n  setOutput(ELM_ID, original[ELM_ID]);\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn check_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\n  let GID = TID + WID; // Global thread ID\n\n  // Load data into shared memory\n  ${ isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, getInput(GID), GID < ELEMENT_COUNT);\" }\n\n  // Perform parallel reduction\n  for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {\n    workgroupBarrier();\n    if (TID % (2u * d) == 0u) {\n      s_data[TID] += s_data[TID + d];\n    }\n  }\n  workgroupBarrier();\n\n  // Write reduction result\n  ${ isLastPass ? last_pass(kernelMode, dataType) : write_reduction_result }\n}`\n\nconst write_reduction_result = /* wgsl */ `\n  if (TID == 0) {\n    setOutput(WORKGROUP_ID, s_data[0]);\n  }\n`\n\nconst first_pass_load_data = /* wgsl */ `\n  let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\n\n  // Load current element into shared memory\n  // Also load next element for comparison\n  let elm = select(0u, getInput(GID), GID < ELEMENT_COUNT);\n  let next = select(0u, getInput(GID + 1), GID < ELEMENT_COUNT-1);\n  s_data[TID] = elm;\n  workgroupBarrier();\n\n  s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\n`\n\nconst last_pass = (kernelMode: string, dataType = 'buffer') => /* wgsl */ `\n  ${\n    dataType === 'buffer'\n      ? 'let fullDispatchLength = arrayLength(&output);'\n      : `\n        let dim = textureDimensions(output);\n        let fullDispatchLength = dim.x * dim.y;\n      `\n  }\n  let dispatchIndex = TID * 3;\n\n  if (dispatchIndex >= fullDispatchLength) {\n    return;\n  }\n\n  ${kernelMode == 'full' ? last_pass_full : last_pass_fast}\n`\n\n// If the fast check kernel is sorted and the data isn't already sorted, run the full check\nconst last_pass_fast = /* wgsl */ `\n  setOutput(dispatchIndex, select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u));\n`\n\n// If the full check kernel is sorted, set the flag to 1 and skip radix sort passes\nconst last_pass_full = /* wgsl */ `\n  if (TID == 0 && s_data[0] == 0) {\n    is_sorted = 1u;\n  }\n\n  setOutput(dispatchIndex, select(0, original[dispatchIndex], s_data[0] != 0));\n`\nexport default checkSortSource;\n","import checkSortSource from '../../shaders/CheckSort';\nimport { BufferKernel } from '../radix-sort/RadixSortBufferKernel';\nimport { AbstractCheckSortKernel, AbstractCheckSortKernelOptions } from './AbstractCheckSortKernel';\n\nexport interface CheckSortBufferKernelOptions extends AbstractCheckSortKernelOptions<BufferKernel> {\n}\n\nexport class CheckSortBufferKernel extends AbstractCheckSortKernel<BufferKernel> {\n  public outputs: Array<GPUBuffer> = [];\n\n  constructor(options: CheckSortBufferKernelOptions) {\n    super(options);\n\n    this.buffers.data = options.data.keys;\n\n    this.createPassesRecursive(options.data, this.count);\n  }\n\n  createPassesRecursive(data: BufferKernel, count: number, passIndex: number = 0) {\n    const workgroupCount = Math.ceil(count / this.threadsPerWorkgroup);\n\n    const isFirstPass = !passIndex;\n    const isLastPass = workgroupCount <= 1;\n\n    const label = `check-sort-${this.mode}-${passIndex}`;\n\n    const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\n      label,\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        // Last pass bindings\n        ...(isLastPass ? [{\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        }, {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType }\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: data.keys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outputBuffer },\n        },\n        // Last pass buffers\n        ...(isLastPass ? [{\n          binding: 2,\n          resource: { buffer: this.buffers.original },\n        }, {\n          binding: 3,\n          resource: { buffer: this.buffers.isSorted },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const elementCount = isFirstPass ? this.start + count : count;\n    const startElement = isFirstPass ? this.start : 0;\n\n    const checkSortPipeline = this.device.createComputePipeline({\n      layout: pipelineLayout,\n      compute: {\n        module: this.device.createShaderModule({\n          label,\n          code: checkSortSource(isFirstPass, isLastPass, this.mode, 'buffer'),\n        }),\n        entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\n        constants: {\n          'ELEMENT_COUNT': elementCount,\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          ...(this.mode !== 'reset' && {\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'START_ELEMENT': startElement,\n          }),\n        },\n      },\n    });\n\n    this.outputs.push(outputBuffer);\n    this.pipelines.push({ pipeline: checkSortPipeline, bindGroup });\n\n    if (!isLastPass) {\n      this.createPassesRecursive({ keys: outputBuffer }, workgroupCount, passIndex + 1);\n    }\n  }\n}","import { AbstractRadixSortKernel, DispatchData, type AbstractRadixSortKernelOptions } from './AbstractRadixSortKernel';\nimport radixSortSource from '../../shaders/RadixSort';\nimport radixSortSourceLocalShuffle from '../../shaders/optimizations/RadixSortLocalShuffle';\nimport reorderSource from '../../shaders/RadixSortReorder';\nimport { findOptimalDispatchSize, removeValues } from '../../utils';\nimport { KernelPipelineDefinition } from '../AbstractKernel';\nimport { CheckSortBufferKernel } from '../check-sort/CheckSortBufferKernel';\n\nexport interface BufferKernel {\n  keys: GPUBuffer;\n  values?: GPUBuffer;\n}\n\nexport interface RadixSortKernelOptions extends AbstractRadixSortKernelOptions<BufferKernel> {\n  localShuffle?: boolean;\n}\n\nexport class RadixSortBufferKernel extends AbstractRadixSortKernel<BufferKernel> {\n  declare localShuffle: boolean;\n\n  constructor(options: RadixSortKernelOptions) {\n    super(options);\n    this.localShuffle = options.localShuffle ?? false;\n\n    this.buffers.keys = options.data.keys;\n    if (options.data.values) {\n      this.buffers.values = options.data.values;\n    }\n\n    this.createShaderModules();\n    this.createPipelines();\n  }\n\n  get hasValues(): boolean {\n    return !!this.data.values;\n  }\n\n  protected get blockSumSource(): string {\n    const source = this.localShuffle\n      ? radixSortSourceLocalShuffle\n      : radixSortSource('buffer')\n    ;\n    return this.hasValues ? source : removeValues(source);\n  }\n\n  protected get reorderSource(): string {\n    return this.hasValues ? reorderSource('buffer') : removeValues(reorderSource('buffer'));\n  }\n\n  protected createResources(): void {\n    // Keys and values double buffering\n    this.buffers.tmpKeys = this.device.createBuffer({\n      label: 'radix-sort-tmp-keys',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    if (this.hasValues) {\n      this.buffers.tmpValues = this.device.createBuffer({\n        label: 'radix-sort-tmp-values',\n        size: this.count * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n      });\n    }\n\n    // Local Prefix Sum buffer (1 element per item)\n    this.buffers.localPrefixSum = this.device.createBuffer({\n      label: 'radix-sort-local-prefix-sum',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n  }\n\n  protected getPassInData(even: boolean): BufferKernel {\n    return {\n      keys: even ? this.buffers.keys : this.buffers.tmpKeys,\n      values: even ? this.buffers.values : this.buffers.tmpValues,\n    };\n  }\n\n  protected getPassOutData(even: boolean): BufferKernel {\n    return {\n      keys: even ? this.buffers.tmpKeys : this.buffers.keys,\n      values: even ? this.buffers.tmpValues : this.buffers.values,\n    };\n  }\n\n  protected createBlockSumPipeline(inData: BufferKernel, bit: number): KernelPipelineDefinition {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-block-sum',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type: this.localShuffle\n              ? 'storage' as GPUBufferBindingType\n              : 'read-only-storage' as GPUBufferBindingType,\n          }\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inData.keys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: this.buffers.localPrefixSum },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n        // \"Local shuffle\" optimization needs access to the values buffer\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          resource: { buffer: inData.values! },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const blockSumPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-block-sum',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.blockSum,\n        entryPoint: 'radix_sort',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: blockSumPipeline,\n      bindGroup,\n    };\n  }\n\n  protected createCheckSortKernels(dispatchData: DispatchData) {\n    if (!this.checkOrder) return;\n\n    const { checkSortFastCount, checkSortFullCount, startFull } = dispatchData;\n\n    // Create the full pass\n    this.kernels.checkSortFull = new CheckSortBufferKernel({\n      mode: 'full',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.dispatchSize,\n      original: this.buffers.originalDispatchSize,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFullCount,\n      start: startFull,\n      workgroupSize: this.workgroupSize,\n    });\n\n    // Create the fast pass\n    this.kernels.checkSortFast = new CheckSortBufferKernel({\n      mode: 'fast',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.checkSortFullDispatchSize,\n      original: this.buffers.originalCheckSortFullDispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: checkSortFastCount,\n      workgroupSize: this.workgroupSize,\n    });\n\n    const initialDispatchElementCount = this.initialDispatch.length / 3;\n\n    if (this.kernels.checkSortFast!.threadsPerWorkgroup < this.kernels.checkSortFull!.pipelines.length || this.kernels.checkSortFull!.threadsPerWorkgroup < initialDispatchElementCount) {\n      console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`);\n      this.checkOrder = false;\n      return;\n    }\n\n    // Create the reset pass\n    this.kernels.checkSortReset = new CheckSortBufferKernel({\n      mode: 'reset',\n      device: this.device,\n      data: this.data,\n      original: this.buffers.originalDispatchSize,\n      result: this.buffers.dispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: initialDispatchElementCount,\n      workgroupSize: findOptimalDispatchSize(this.device, initialDispatchElementCount),\n    });\n  }\n\n  protected createReorderPipeline(inData: BufferKernel, outData: BufferKernel, bit: number): KernelPipelineDefinition {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-reorder',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n          },\n          {\n            binding: 5,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'storage' as GPUBufferBindingType },\n          },\n        ] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inData.keys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outData.keys },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.localPrefixSum },\n        },\n        {\n          binding: 3,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            resource: { buffer: inData.values! },\n          },\n          {\n            binding: 5,\n            resource: { buffer: outData.values! },\n          },\n        ] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const reorderPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-reorder',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.reorder,\n        entryPoint: 'radix_sort_reorder',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: reorderPipeline,\n      bindGroup,\n    };\n  }\n}\n","import checkSortSource from '../../shaders/CheckSort';\nimport type { TextureKernel } from '../radix-sort/RadixSortTextureKernel';\nimport { bufferToTexture } from '../../utils';\nimport { AbstractCheckSortKernel, type AbstractCheckSortKernelOptions } from './AbstractCheckSortKernel';\n\nexport interface CheckSortTextureKernelOptions extends AbstractCheckSortKernelOptions<TextureKernel> {\n}\n\nexport class CheckSortTextureKernel extends AbstractCheckSortKernel<TextureKernel> {\n  public textures: Record<string, GPUTexture> = {};\n\n  public outputs: Array<GPUTexture> = [];\n\n  constructor(options: CheckSortTextureKernelOptions) {\n    super(options);\n\n    this.textures.read = options.data.texture;\n\n    this.createPassesRecursive(options.data, this.count);\n  }\n\n  createPassesRecursive(data: TextureKernel, count: number, passIndex: number = 0) {\n    const workgroupCount = Math.ceil(count / this.threadsPerWorkgroup);\n\n    const isFirstPass = !passIndex;\n    const isLastPass = workgroupCount <= 1;\n\n    const label = `check-sort-${this.mode}-${passIndex}`;\n\n    const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\n      label,\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const outputTexture = bufferToTexture(this.device, outputBuffer);\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-write',\n            format: 'r32uint',\n            viewDimension: '2d',\n          },\n        },\n        // Last pass bindings\n        ...(isLastPass ? [{\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        }, {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType }\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: data.texture.createView(),\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n        // Last pass buffers\n        ...(isLastPass ? [{\n          binding: 2,\n          resource: { buffer: this.buffers.original },\n        }, {\n          binding: 3,\n          resource: { buffer: this.buffers.isSorted },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const elementCount = isFirstPass ? this.start + count : count;\n    const startElement = isFirstPass ? this.start : 0;\n\n    const checkSortPipeline = this.device.createComputePipeline({\n      layout: pipelineLayout,\n      compute: {\n        module: this.device.createShaderModule({\n          label,\n          code: checkSortSource(isFirstPass, isLastPass, this.mode, 'texture'),\n        }),\n        entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\n        constants: {\n          'ELEMENT_COUNT': elementCount,\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          ...(this.mode !== 'reset' && {\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'START_ELEMENT': startElement,\n          }),\n        },\n      },\n    });\n\n    this.outputs.push(outputTexture);\n    this.pipelines.push({ pipeline: checkSortPipeline, bindGroup });\n\n    if (!isLastPass) {\n      this.createPassesRecursive({ texture: outputTexture }, workgroupCount, passIndex + 1);\n    }\n  }\n}","import { AbstractRadixSortKernel, type DispatchData, type AbstractRadixSortKernelOptions } from './AbstractRadixSortKernel';\nimport radixSortSource from '../../shaders/RadixSort';\nimport reorderSource from '../../shaders/RadixSortReorder';\nimport type { KernelPipelineDefinition } from '../AbstractKernel';\nimport { CheckSortTextureKernel } from '../check-sort/CheckSortTextureKernel';\nimport { findOptimalDispatchSize } from '../../utils';\n\nexport interface TextureKernel {\n  texture: GPUTexture;\n}\n\nexport interface RadixSortKernelOptions extends AbstractRadixSortKernelOptions<TextureKernel> {\n}\n\nexport class RadixSortTextureKernel extends AbstractRadixSortKernel<TextureKernel> {\n  public textures: Record<string, GPUTexture> = {};\n\n  constructor(options: RadixSortKernelOptions) {\n    super(options);\n\n    this.textures.read = options.data.texture;\n\n    this.createShaderModules();\n    this.createPipelines();\n  }\n\n  get hasValues(): boolean {\n    return true;\n  }\n\n  protected get blockSumSource(): string {\n    return radixSortSource('texture');\n  }\n\n  protected get reorderSource(): string {\n    return reorderSource('texture');\n  }\n\n  protected createResources(): void {\n    // Write texture\n    this.textures.write = this.device.createTexture({\n      size: {\n        width: this.textures.read.width,\n        height: this.textures.read.height,\n      },\n      format: this.textures.read.format,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n    });\n\n    // Local Prefix Sum texture\n    this.textures.localPrefixSum = this.device.createTexture({\n      size: {\n        width: this.textures.read.width,\n        height: this.textures.read.height,\n      },\n      format: 'r32uint',\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n    });\n  }\n\n  protected getPassInData(even: boolean): TextureKernel {\n    return {\n      texture: even ? this.textures.read : this.textures.write,\n    };\n  }\n\n  protected getPassOutData(even: boolean): TextureKernel {\n    return {\n      texture: even ? this.textures.write : this.textures.read,\n    };\n  }\n\n  protected createBlockSumPipeline(inData: TextureKernel, bit: number) {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-block-sum',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'write-only',\n            format: 'r32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: inData.texture.createView(),\n        },\n        {\n          binding: 1,\n          resource: this.textures.localPrefixSum.createView(),\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const blockSumPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-block-sum',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.blockSum,\n        entryPoint: 'radix_sort',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: blockSumPipeline,\n      bindGroup,\n    };\n  }\n\n  protected createCheckSortKernels(dispatchData: DispatchData) {\n    if (!this.checkOrder) return;\n\n    const { checkSortFastCount, checkSortFullCount, startFull } = dispatchData;\n\n    // Create the full pass\n    this.kernels.checkSortFull = new CheckSortTextureKernel({\n      mode: 'full',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.dispatchSize,\n      original: this.buffers.originalDispatchSize,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFullCount,\n      start: startFull,\n      workgroupSize: this.workgroupSize,\n    });\n\n    // Create the fast pass\n    this.kernels.checkSortFast = new CheckSortTextureKernel({\n      mode: 'fast',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.checkSortFullDispatchSize,\n      original: this.buffers.originalCheckSortFullDispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: checkSortFastCount,\n      workgroupSize: this.workgroupSize,\n    });\n\n    const initialDispatchElementCount = this.initialDispatch.length / 3;\n\n    if (this.kernels.checkSortFast!.threadsPerWorkgroup < this.kernels.checkSortFull!.pipelines.length || this.kernels.checkSortFull!.threadsPerWorkgroup < initialDispatchElementCount) {\n      console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`);\n      this.checkOrder = false;\n      return;\n    }\n\n    // Create the reset pass\n    this.kernels.checkSortReset = new CheckSortTextureKernel({\n      mode: 'reset',\n      device: this.device,\n      data: this.data,\n      original: this.buffers.originalDispatchSize,\n      result: this.buffers.dispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: initialDispatchElementCount,\n      workgroupSize: findOptimalDispatchSize(this.device, initialDispatchElementCount),\n    });\n  }\n\n  protected createReorderPipeline(inData: TextureKernel, outData: TextureKernel, bit: number): KernelPipelineDefinition {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-reorder',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'write-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-write',\n            format: 'r32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: inData.texture.createView(),\n        },\n        {\n          binding: 1,\n          resource: outData.texture.createView(),\n        },\n        {\n          binding: 2,\n          resource: this.textures.localPrefixSum.createView(),\n        },\n        {\n          binding: 3,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const reorderPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-reorder',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.reorder,\n        entryPoint: 'radix_sort_reorder',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: reorderPipeline,\n      bindGroup,\n    };\n  }\n}\n"],"names":["AbstractKernel","options","key","val","findOptimalDispatchSize","device","workgroupCount","dispatchSize","x","y","createBufferFromData","label","data","usage","dispatchSizes","bufferToTexture","buffer","TEXTURE_WIDTH","TEXTURE_HEIGHT","texture","command","removeValues","source","line","prefixSumSource","prefixSumSourceNoBankConflict","PrefixSumKernel","count","workgroupSize","avoidBankConflicts","blockSumBuffer","bindGroupLayout","bindGroup","pipelineLayout","scanPipeline","blockSumPipeline","p","pass","dispatchSizeBuffer","offset","pipeline","i","AbstractCheckSortKernel","itemCount","threadsPerWorkgroup","sizes","targetWorkgroupCount","dispatchIndirect","AbstractRadixSortKernel","#createPrefixSumKernel","dispatchData","#calculateDispatchSizes","#createCheckSortBuffers","bit","even","inData","outData","reorderPipeline","prefixBlockSumBuffer","prefixSumKernel","prefixSumDispatchSize","checkSortFastCount","checkSortFullCount","startFull","dispatchSizesFast","dispatchSizesFull","initialDispatch","#dispatchPipelinesIndirect","#dispatchPipelines","radixSortSource","dataType","radixSortSourceLocalShuffle","reorderSource","checkSortSource","isFirstPass","isLastPass","kernelMode","first_pass_load_data","last_pass","write_reduction_result","last_pass_full","last_pass_fast","CheckSortBufferKernel","passIndex","outputBuffer","elementCount","startElement","checkSortPipeline","RadixSortBufferKernel","initialDispatchElementCount","CheckSortTextureKernel","outputTexture","RadixSortTextureKernel"],"mappings":"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"}