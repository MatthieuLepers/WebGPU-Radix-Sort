{"version":3,"file":"radix-sort.umd.js","sources":["../src/kernels/AbstractKernel.ts","../src/utils.ts","../src/shaders/PrefixSum.ts","../src/shaders/optimizations/PrefixSumNoBankConflict.ts","../src/kernels/PrefixSumKernel.ts","../src/kernels/check-sort/AbstractCheckSortKernel.ts","../src/kernels/radix-sort/AbstractRadixSortKernel.ts","../src/shaders/RadixSort.ts","../src/shaders/optimizations/RadixSortLocalShuffle.ts","../src/shaders/RadixSortReorder.ts","../src/shaders/CheckSort.ts","../src/kernels/check-sort/CheckSortBufferKernel.ts","../src/kernels/radix-sort/RadixSortBufferKernel.ts","../src/kernels/check-sort/CheckSortTextureKernel.ts","../src/kernels/radix-sort/RadixSortTextureKernel.ts"],"sourcesContent":["import type { DispatchSize, WorkgroupSize } from '../utils';\n\nexport interface AbstractKernelOptions {\n  device: GPUDevice;\n  count: number;\n  workgroupSize?: WorkgroupSize;\n}\n\nexport interface KernelPipelineDefinition {\n  pipeline: GPUComputePipeline;\n  bindGroup: GPUBindGroup;\n  dispatchSize?: DispatchSize;\n}\n\nexport abstract class AbstractKernel {\n  public options: AbstractKernelOptions;\n\n  declare device: GPUDevice;\n\n  declare count: number;\n\n  public workgroupSize: WorkgroupSize = {\n    x: 16,\n    y: 16,\n  };\n\n  public pipelines: Array<KernelPipelineDefinition> = [];\n\n  protected shaderModules: Record<string, GPUShaderModule> = {};\n\n  constructor(options: AbstractKernelOptions) {\n    this.options = options;\n    Object.keys(options).forEach((key) => {\n      Object.defineProperty(this, key, {\n        get: () => this.options[key as keyof AbstractKernelOptions],\n        set: (val) => { this.options[key as keyof AbstractKernelOptions] = val; },\n      });\n    });\n  }\n\n  get workgroupCount(): number {\n    return Math.ceil(this.count / this.threadsPerWorkgroup);\n  }\n\n  get threadsPerWorkgroup(): number {\n    return this.workgroupSize.x * this.workgroupSize.y\n  }\n\n  get itemsPerWorkgroup(): number {\n    return 2 * this.threadsPerWorkgroup;\n  }\n\n  abstract dispatch(\n    passEncoder: GPUComputePassEncoder,\n    dispatchSizeBuffer?: GPUBuffer,\n    offset?: number,\n  ): void;\n}\n","export type WorkgroupSize = {\n  x: number;\n  y: number;\n}\n\nexport type DispatchSize = WorkgroupSize;\n\nexport function findOptimalDispatchSize(device: GPUDevice, workgroupCount: number) {\n  const dispatchSize = { \n    x: workgroupCount, \n    y: 1,\n  };\n\n  if (workgroupCount > device.limits.maxComputeWorkgroupsPerDimension) {\n    const x = Math.floor(Math.sqrt(workgroupCount));\n    const y = Math.ceil(workgroupCount / x);\n\n    dispatchSize.x = x;\n    dispatchSize.y = y;\n  }\n\n  return dispatchSize;\n}\n\nexport function createBufferFromData({ device, label, data, usage = 0 }: {\n  device: GPUDevice,\n  label: string,\n  data: number[],\n  usage: number,\n}) {\n  const dispatchSizes = device.createBuffer({\n    label,\n    usage,\n    size: data.length * 4,\n    mappedAtCreation: true,\n  });\n\n  const dispatchData = new Uint32Array(dispatchSizes.getMappedRange());\n  dispatchData.set(data);\n  dispatchSizes.unmap();\n\n  return dispatchSizes;\n}\n\nexport function bufferToTexture(device: GPUDevice, buffer: GPUBuffer): GPUTexture {\n  const TEXTURE_WIDTH = Math.min(8192, buffer.size);\n  const TEXTURE_HEIGHT = Math.ceil((buffer.size) / TEXTURE_WIDTH);\n\n  const texture = device.createTexture({\n    size: {\n      width: TEXTURE_WIDTH,\n      height: TEXTURE_HEIGHT,\n    },\n    format: 'r32uint',\n    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n  });\n  const command = device.createCommandEncoder();\n  command.copyBufferToTexture({ buffer }, { texture }, [texture.width, texture.height, texture.depthOrArrayLayers]);\n  device.queue.submit([command.finish()]);\n\n  return texture;\n}\n\nexport const removeValues = (source: string) => source\n  .split('\\n')\n  .filter((line) => !line.toLowerCase().includes('values'))\n  .join('\\n')\n;\n","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  temp[ELM_TID]      = select(items[ELM_GID], 0u, ELM_GID >= ELEMENT_COUNT);\n  temp[ELM_TID + 1u] = select(items[ELM_GID + 1u], 0u, ELM_GID + 1u >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n    // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    let last_offset = ITEMS_PER_WORKGROUP - 1u;\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (ELM_GID >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID] = temp[ELM_TID];\n\n  if (ELM_GID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID + 1u] = temp[ELM_TID + 1u];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nconst NUM_BANKS: u32 = 32u;\nconst LOG_NUM_BANKS: u32 = 5u;\n\nfn get_offset(offset: u32) -> u32 {\n  // return offset >> LOG_NUM_BANKS; // Conflict-free\n  return (offset >> NUM_BANKS) + (offset >> (2u * LOG_NUM_BANKS)); // Zero bank conflict\n}\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  let ai: u32 = TID;\n  let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1u);\n  let s_ai = ai + get_offset(ai);\n  let s_bi = bi + get_offset(bi);\n  let g_ai = ai + WID * 2u;\n  let g_bi = bi + WID * 2u;\n  temp[s_ai] = select(items[g_ai], 0u, g_ai >= ELEMENT_COUNT);\n  temp[s_bi] = select(items[g_bi], 0u, g_bi >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n  // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    var last_offset = ITEMS_PER_WORKGROUP - 1u;\n    last_offset += get_offset(last_offset);\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (g_ai < ELEMENT_COUNT) {\n    items[g_ai] = temp[s_ai];\n  }\n  if (g_bi < ELEMENT_COUNT) {\n    items[g_bi] = temp[s_bi];\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","import { findOptimalDispatchSize } from '../utils';\nimport prefixSumSource from '../shaders/PrefixSum';\nimport prefixSumSourceNoBankConflict from '../shaders/optimizations/PrefixSumNoBankConflict';\nimport { AbstractKernel, type AbstractKernelOptions } from './AbstractKernel';\n\ninterface IPrefixSumKernelOptions extends AbstractKernelOptions {\n  data: GPUBuffer;\n  avoidBankConflicts?: boolean;\n}\n\nexport class PrefixSumKernel extends AbstractKernel {\n  /**\n   * Perform a parallel prefix sum on the given data buffer\n   * \n   * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\n   * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - Max number of elements to process\n   * @param {WorkgroupSize} workgroupSize - Workgroup size in x and y dimensions. (x * y) must be a power of two\n   * @param {GPUBuffer} data - Buffer containing the data to process\n   * @param {boolean} avoidBankConflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    data,\n    avoidBankConflicts = false\n  }: IPrefixSumKernelOptions) {\n    super({ device, count, workgroupSize });\n\n    if (Math.log2(this.threadsPerWorkgroup) % 1 !== 0) {\n      throw new Error(`workgroupSize.x * workgroupSize.y must be a power of two. (current: ${this.threadsPerWorkgroup})`);\n    }\n\n    this.shaderModules.prefixSum = this.device.createShaderModule({\n      label: 'prefix-sum',\n      code: avoidBankConflicts ? prefixSumSourceNoBankConflict : prefixSumSource,\n    })\n\n    this.createPassRecursive(data, count);\n  }\n\n  createPassRecursive(data: GPUBuffer, count: number) {\n    // Find best dispatch x and y dimensions to minimize unused threads\n    const workgroupCount = Math.ceil(count / this.itemsPerWorkgroup);\n    const dispatchSize = findOptimalDispatchSize(this.device, workgroupCount);\n\n    // Create buffer for block sums\n    const blockSumBuffer = this.device.createBuffer({\n      label: 'prefix-sum-block-sum',\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create bind group and pipeline layout\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      label: 'prefix-sum-bind-group',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: data },\n        },\n        {\n          binding: 1,\n          resource: { buffer: blockSumBuffer },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [ bindGroupLayout ],\n    });\n\n    // Per-workgroup (block) prefix sum\n    const scanPipeline = this.device.createComputePipeline({\n      label: 'prefix-sum-scan-pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.prefixSum,\n        entryPoint: 'reduce_downsweep',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ITEMS_PER_WORKGROUP': this.itemsPerWorkgroup,\n          'ELEMENT_COUNT': count,\n        },\n      },\n    });\n\n    this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize });\n\n    if (workgroupCount > 1) {\n      // Prefix sum on block sums\n      this.createPassRecursive(blockSumBuffer, workgroupCount);\n\n      // Add block sums to local prefix sums\n      const blockSumPipeline = this.device.createComputePipeline({\n        label: 'prefix-sum-add-block-pipeline',\n        layout: pipelineLayout,\n        compute: {\n          module: this.shaderModules.prefixSum,\n          entryPoint: 'add_block_sums',\n          constants: {\n            'WORKGROUP_SIZE_X': this.workgroupSize.x,\n            'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'ELEMENT_COUNT': count,\n          },\n        },\n      });\n\n      this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize });\n    }\n  }\n\n  getDispatchChain() {\n    return this.pipelines.flatMap((p) => [ p.dispatchSize!.x, p.dispatchSize!.y, 1 ]);\n  }\n\n  /**\n   * Encode the prefix sum pipeline into the current pass.\n   * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\n   *\n   * @param {GPUComputePassEncoder} pass\n   * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\n   * @param {number} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\n   */\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup, dispatchSize }, i) => {\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (!dispatchSizeBuffer) {\n        pass.dispatchWorkgroups(dispatchSize!.x, dispatchSize!.y, 1);\n      } else {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      }\n    });\n  }\n}\n","import { AbstractKernel, type AbstractKernelOptions } from '../AbstractKernel';\nimport { findOptimalDispatchSize, WorkgroupSize } from '../../utils';\n\nexport interface AbstractCheckSortKernelOptions<T> extends AbstractKernelOptions {\n  data: T;\n  result: GPUBuffer;\n  original: GPUBuffer;\n  isSorted: GPUBuffer;\n  start?: number;\n  mode?: 'full' | 'fast' | 'reset';\n}\n\nexport abstract class AbstractCheckSortKernel<T> extends AbstractKernel {\n  declare start: number;\n\n  declare mode: 'full' | 'fast' | 'reset';\n\n  public buffers: Record<string, GPUBuffer> = {};\n\n  constructor(options: AbstractCheckSortKernelOptions<T>) {\n    super(options);\n    this.start = options.start ?? 0;\n    this.mode = options.mode ?? 'full';\n\n    this.buffers.result = options.result;\n    this.buffers.original = options.original;\n    this.buffers.isSorted = options.isSorted;\n  }\n\n  // Find the best dispatch size for each pass to minimize unused workgroups\n  static findOptimalDispatchChain(device: GPUDevice, itemCount: number, workgroupSize: WorkgroupSize) {\n    const threadsPerWorkgroup = workgroupSize.x * workgroupSize.y;\n    const sizes = [];\n\n    do {\n      // Number of workgroups required to process all items\n      const targetWorkgroupCount = Math.ceil(itemCount / threadsPerWorkgroup);\n\n      // Optimal dispatch size and updated workgroup count\n      const dispatchSize = findOptimalDispatchSize(device, targetWorkgroupCount);\n\n      sizes.push(dispatchSize.x, dispatchSize.y, 1);\n      itemCount = targetWorkgroupCount;\n    } while (itemCount > 1);\n\n    return sizes;\n  }\n\n  protected abstract createPassesRecursive(data: T, count: number, passIndex: number): void;\n\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup }, i) => {\n      const dispatchIndirect = this.mode !== 'reset' && (this.mode === 'full' || i < this.pipelines.length - 1);\n\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (dispatchIndirect && dispatchSizeBuffer) {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      } else {\n        // Only the reset kernel and the last dispatch of the fast check kernel are constant to (1, 1, 1)\n        pass.dispatchWorkgroups(1, 1, 1);\n      }\n    });\n  }\n}\n","import { AbstractKernel, type KernelPipelineDefinition, type AbstractKernelOptions } from '../AbstractKernel';\nimport { PrefixSumKernel } from '../PrefixSumKernel';\nimport { createBufferFromData, findOptimalDispatchSize, type DispatchSize } from '../../utils';\nimport { AbstractCheckSortKernel } from '../check-sort/AbstractCheckSortKernel';\n\nexport interface DispatchData {\n  initialDispatch: Array<number>;\n  dispatchSizesFull: Array<number>;\n  checkSortFastCount: number;\n  checkSortFullCount: number;\n  startFull: number;\n}\n\nexport interface AbstractRadixSortKernelOptions<T> extends AbstractKernelOptions {\n  data: T;\n  bitCount?: number;\n  checkOrder?: boolean;\n  avoidBankConflicts?: boolean;\n}\n\nexport abstract class AbstractRadixSortKernel<T> extends AbstractKernel {\n  declare data: T;\n\n  declare bitCount: number;\n\n  declare checkOrder: boolean;\n\n  declare avoidBankConflicts: boolean;\n\n  public buffers: Record<string, GPUBuffer> = {};\n\n  protected kernels: {\n    prefixSum?: PrefixSumKernel;\n    checkSortReset?: AbstractCheckSortKernel<T>;\n    checkSortFast?: AbstractCheckSortKernel<T>;\n    checkSortFull?: AbstractCheckSortKernel<T>;\n  } = {};\n\n  private dispatchSize: DispatchSize = {\n    x: 1,\n    y: 1,\n  };\n\n  private dispatchOffsets = {\n    radixSort: 0,\n    checkSortFast: 3 * 4,\n    prefixSum: 6 * 4\n  };\n\n  protected initialDispatch: Array<number> = [];\n\n  constructor(options: AbstractRadixSortKernelOptions<T>) {\n    super(options);\n    this.bitCount = options.bitCount ?? 32;\n    this.checkOrder = options.checkOrder ?? false;\n    this.avoidBankConflicts = options.avoidBankConflicts ?? false;\n  }\n\n  get prefixBlockWorkgroupCount(): number {\n    return 4 * this.workgroupCount;\n  }\n\n  abstract get hasValues(): boolean;\n\n  protected abstract get blockSumSource(): string;\n\n  protected abstract get reorderSource(): string;\n\n  protected createShaderModules() {\n    this.shaderModules.blockSum = this.device.createShaderModule({\n      label: 'radix-sort-block-sum',\n      code: this.blockSumSource,\n    });\n    this.shaderModules.reorder = this.device.createShaderModule({\n      label: 'radix-sort-reorder',\n      code: this.reorderSource,\n    });\n  }\n\n  protected createPipelines() {\n    // Block prefix sum kernel\n    this.#createPrefixSumKernel();\n\n    // Indirect dispatch buffers\n    const dispatchData = this.#calculateDispatchSizes();\n\n    // GPU resources (buffers / textures)\n    this.createResources();\n    this.#createCheckSortBuffers(dispatchData);\n\n    this.createCheckSortKernels(dispatchData);\n\n    // Radix sort passes for every 2 bits\n    for (let bit = 0; bit < this.bitCount; bit += 2) {\n      // Swap buffers every pass\n      const even = (bit % 4 === 0);\n      const inData = this.getPassInData(even);\n      const outData = this.getPassOutData(even);\n\n      // Compute local prefix sums and block sums\n      const blockSumPipeline = this.createBlockSumPipeline(inData, bit);\n\n      // Reorder keys and values\n      const reorderPipeline = this.createReorderPipeline(inData, outData, bit);\n\n      this.pipelines.push(blockSumPipeline, reorderPipeline);\n    }\n  }\n\n  #createPrefixSumKernel() {\n    // Prefix Block Sum buffer (4 element per workgroup)\n    const prefixBlockSumBuffer = this.device.createBuffer({\n      label: 'radix-sort-prefix-block-sum',\n      size: this.prefixBlockWorkgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create block prefix sum kernel\n    const prefixSumKernel = new PrefixSumKernel({\n      device: this.device,\n      data: prefixBlockSumBuffer,\n      count: this.prefixBlockWorkgroupCount,\n      workgroupSize: this.workgroupSize,\n      avoidBankConflicts: this.avoidBankConflicts,\n    });\n\n    this.kernels.prefixSum = prefixSumKernel;\n    this.buffers.prefixBlockSum = prefixBlockSumBuffer;\n  }\n\n  #calculateDispatchSizes(): DispatchData {\n    // Radix sort dispatch size\n    const dispatchSize = findOptimalDispatchSize(this.device, this.workgroupCount);\n\n    // Prefix sum dispatch sizes\n    const prefixSumDispatchSize = this.kernels.prefixSum!.getDispatchChain();\n\n    // Check sort element count (fast/full)\n    const checkSortFastCount = Math.min(this.count, this.threadsPerWorkgroup * 4);\n    const checkSortFullCount = this.count - checkSortFastCount;\n    const startFull = checkSortFastCount - 1;\n\n    // Check sort dispatch sizes\n    const dispatchSizesFast = AbstractCheckSortKernel.findOptimalDispatchChain(this.device, checkSortFastCount, this.workgroupSize);\n    const dispatchSizesFull = AbstractCheckSortKernel.findOptimalDispatchChain(this.device, checkSortFullCount, this.workgroupSize);\n\n    // Initial dispatch sizes\n    const initialDispatch = [\n      dispatchSize.x, dispatchSize.y, 1, // Radix Sort + Reorder\n      ...dispatchSizesFast.slice(0, 3),  // Check sort fast\n      ...prefixSumDispatchSize,          // Prefix Sum\n    ];\n\n    this.dispatchSize = dispatchSize;\n    this.initialDispatch = initialDispatch;\n\n    return {\n      initialDispatch,\n      dispatchSizesFull,\n      checkSortFastCount,\n      checkSortFullCount,\n      startFull,\n    };\n  }\n\n  protected abstract createResources(): void;\n\n  protected abstract getPassInData(even: boolean): T;\n\n  protected abstract getPassOutData(even: boolean): T;\n\n  #createCheckSortBuffers(dispatchData: DispatchData) {\n    // Only create indirect dispatch buffers when checkOrder optimization is enabled\n    if (!this.checkOrder) {\n      return;\n    }\n\n    // Dispatch sizes (radix sort, check sort, prefix sum)\n    this.buffers.dispatchSize = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    this.buffers.originalDispatchSize = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size-original',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Dispatch sizes (full sort)\n    this.buffers.checkSortFullDispatchSize = createBufferFromData({\n      label: 'check-sort-full-dispatch-size',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    this.buffers.originalCheckSortFullDispatchSize = createBufferFromData({\n      label: 'check-sort-full-dispatch-size-original',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Flag to tell if the data is sorted\n    this.buffers.isSorted = createBufferFromData({\n      label: 'is-sorted',\n      device: this.device,\n      data: [0],\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n  }\n\n  protected abstract createCheckSortKernels(dispatchData: DispatchData): void;\n\n  protected abstract createBlockSumPipeline(inData: T, bit: number): KernelPipelineDefinition;\n\n  protected abstract createReorderPipeline(inData: T, outData: T, bit: number): KernelPipelineDefinition;\n\n  dispatch(pass: GPUComputePassEncoder) {\n    if (!this.checkOrder) {\n      this.#dispatchPipelines(pass);\n    } else {\n      this.#dispatchPipelinesIndirect(pass);\n    }\n  }\n\n  #dispatchPipelines(pass: GPUComputePassEncoder) {\n    for (let i = 0; i < this.bitCount / 2; i += 1) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n    }\n  }\n\n  #dispatchPipelinesIndirect(pass: GPUComputePassEncoder) {\n    // Reset the `dispatch` and `is_sorted` buffers\n    this.kernels.checkSortReset!.dispatch(pass);\n\n    for (let i = 0; i < this.bitCount / 2; i++) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      if (i % 2 == 0) {\n        // Check if the data is sorted every 2 passes\n        this.kernels.checkSortFast!.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.checkSortFast);\n        this.kernels.checkSortFull!.dispatch(pass, this.buffers.checkSortFullDispatchSize);\n      }\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefixSum);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n    }\n  }\n}\n","const radixSortSource = (dataType: 'buffer' | 'texture') => /* wgsl */ `\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(0) var<storage, read> input: array<u32>;\n      @group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n    `\n    : `\n      @group(0) @binding(0) var input: texture_storage_2d<rg32uint, read>;\n      @group(0) @binding(1) var local_prefix_sums: texture_storage_2d<r32uint, write>;\n    `\n}\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\n\nfn getInput(index: u32) -> u32 {\n  ${\n    dataType === 'buffer'\n      ? `return input[index];`\n      : `\n        let dimX = textureDimensions(input).r;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        return textureLoad(input, vec2<i32>(x, y)).x;\n      `\n  }\n}\n\nfn setLocalPrefixSum(index: u32, val: u32) {\n  ${\n    dataType === 'buffer'\n      ? 'local_prefix_sums[index] = val;'\n      : `\n        let dimX = textureDimensions(local_prefix_sums).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        textureStore(local_prefix_sums, vec2<i32>(x, y), vec4<u32>(val, 0u, 0u, 0u));\n      `\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  let elm = select(getInput(GID), 0u, GID >= ELEMENT_COUNT);\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu;\n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  if (GID < ELEMENT_COUNT) {\n    // Store local prefix sum to global memory\n    setLocalPrefixSum(GID, bit_prefix_sums[extract_bits]);\n  }\n}\n`;\n\nexport default radixSortSource;\n","export default `\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  var elm: u32 = 0u;\n  var val: u32 = 0u;\n  if (GID < ELEMENT_COUNT) {\n    elm = input[GID];\n    val = values[GID];\n  }\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu; \n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  let prefix_sum = bit_prefix_sums[extract_bits];   \n\n  // Scan bit prefix sums\n  if (TID == LAST_THREAD) {\n    var sum: u32 = 0u;\n    bit_prefix_sums[extract_bits] += 1u;\n\n    for (var i: u32 = 0u; i < 4u; i++) {\n      s_prefix_sum_scan[i] = sum;\n      sum += bit_prefix_sums[i];\n    }\n  }\n  workgroupBarrier();\n\n  if (GID < ELEMENT_COUNT) {\n    // Compute new position\n    let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\n\n    // Shuffle elements locally\n    input[WID + new_pos] = elm;\n    values[WID + new_pos] = val;\n    local_prefix_sums[WID + new_pos] = prefix_sum;\n  }\n}\n`;\n","const reorderSource = (dataType: 'buffer' | 'texture') => `\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\n      @group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\n      @group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\n    `\n    : `\n      @group(0) @binding(0) var input: texture_storage_2d<rg32uint, read>;\n      @group(0) @binding(1) var output: texture_storage_2d<rg32uint, write>;\n      @group(0) @binding(2) var local_prefix_sum: texture_storage_2d<r32uint, read_write>;\n    `\n}\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(4) var<storage, read> inputValues: array<u32>;\n      @group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\n    `\n    : ''\n}\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nfn getInput(index: u32) -> vec2<u32> {\n  ${\n    dataType === 'buffer'\n      ? `\n        let result: vec2<u32> = vec2<u32>(\n          inputKeys[index],\n          inputValues[index]\n        );\n        return result;\n      `\n      : `\n        let dimX = textureDimensions(input).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimY);\n        return textureLoad(input, vec2<i32>(x, y)).xy;\n      `\n  }\n}\n\nfn setOutput(index: u32, key: u32, val: u32) {\n  ${\n    dataType === 'buffer'\n      ? `\n        outputKeys[index] = key;\n        outputValues[index] = val;\n      `\n      : `\n        let dimX = textureDimensions(output).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        textureStore(output, vec2<i32>(x, y), vec4<u32>(key, val, 0u, 0u));\n      `\n  }\n}\n\nfn getLocalPrefixSum(index: u32) -> u32 {\n  ${\n    dataType === 'buffer'\n      ? 'return local_prefix_sum[index];'\n      : `\n        let dimX = textureDimensions(local_prefix_sum).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        return textureLoad(local_prefix_sum, vec2<i32>(x, y)).x;\n      `\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort_reorder(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  if (GID >= ELEMENT_COUNT) { return; }\n\n  let input = getInput(GID);\n\n  let local_prefix = getLocalPrefixSum(GID);\n\n  // Calculate new position\n  let extract_bits = (input.x >> CURRENT_BIT) & 0x3u;\n  let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\n  let sorted_position = prefix_block_sum[pid] + local_prefix;\n\n  setOutput(sorted_position, input.x, input.y);\n}\n`;\n\nexport default reorderSource;\n","const checkSortSource = (isFirstPass = false, isLastPass = false, kernelMode = 'full', dataType: 'buffer' | 'texture') => /* wgsl */ `\n${\n  dataType === 'buffer'\n    ? `\n      @group(0) @binding(0) var<storage, read> input: array<u32>;\n      @group(0) @binding(1) var<storage, read_write> output: array<u32>;\n    `\n    : `\n      @group(0) @binding(0) var input: texture_storage_2d<rg32uint, read>;\n      @group(0) @binding(1) var output: texture_storage_2d<r32uint, write>;\n    `\n}\n@group(0) @binding(2) var<storage, read> original: array<u32>;\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\noverride START_ELEMENT: u32;\n\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\n\nfn getInput(index: u32) -> u32 {\n  ${\n    dataType === 'buffer'\n      ? 'return input[index];'\n      : `\n        let dimX = textureDimensions(input).r;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        return textureLoad(input, vec2<i32>(x, y)).x;\n      `\n  }\n}\n\nfn setOutput(index: u32, data: u32) {\n  ${\n    dataType === 'buffer'\n      ? 'output[index] = data;'\n      : `\n        let dimX = textureDimensions(output).x;\n        let x = i32(index % dimX);\n        let y = i32(index / dimX);\n        textureStore(output, vec2<i32>(x, y), vec4<u32>(data, 0u, 0u, 0u));\n      `\n  }\n}\n\n// Reset dispatch buffer and is_sorted flag\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reset(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  if (TID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  if (TID == 0) {\n    is_sorted = 0u;\n  }\n\n  let ELM_ID = TID * 3;\n\n  setOutput(ELM_ID, original[ELM_ID]);\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn check_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\n  let GID = TID + WID; // Global thread ID\n\n  // Load data into shared memory\n  ${ isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, getInput(GID), GID < ELEMENT_COUNT);\" }\n\n  // Perform parallel reduction\n  for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {\n    workgroupBarrier();\n    if (TID % (2u * d) == 0u) {\n      s_data[TID] += s_data[TID + d];\n    }\n  }\n  workgroupBarrier();\n\n  // Write reduction result\n  ${ isLastPass ? last_pass(kernelMode, dataType) : write_reduction_result }\n}`\n\nconst write_reduction_result = /* wgsl */ `\n  if (TID == 0) {\n    setOutput(WORKGROUP_ID, s_data[0]);\n  }\n`\n\nconst first_pass_load_data = /* wgsl */ `\n  let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\n\n  // Load current element into shared memory\n  // Also load next element for comparison\n  let elm = select(0u, getInput(GID), GID < ELEMENT_COUNT);\n  let next = select(0u, getInput(GID + 1), GID < ELEMENT_COUNT-1);\n  s_data[TID] = elm;\n  workgroupBarrier();\n\n  s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\n`\n\nconst last_pass = (kernelMode: string, dataType = 'buffer') => /* wgsl */ `\n  ${\n    dataType === 'buffer'\n      ? 'let fullDispatchLength = arrayLength(&output);'\n      : `\n        let dim = textureDimensions(output);\n        let fullDispatchLength = dim.x * dim.y;\n      `\n  }\n  let dispatchIndex = TID * 3;\n\n  if (dispatchIndex >= fullDispatchLength) {\n    return;\n  }\n\n  ${kernelMode == 'full' ? last_pass_full : last_pass_fast}\n`\n\n// If the fast check kernel is sorted and the data isn't already sorted, run the full check\nconst last_pass_fast = /* wgsl */ `\n  setOutput(dispatchIndex, select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u));\n`\n\n// If the full check kernel is sorted, set the flag to 1 and skip radix sort passes\nconst last_pass_full = /* wgsl */ `\n  if (TID == 0 && s_data[0] == 0) {\n    is_sorted = 1u;\n  }\n\n  setOutput(dispatchIndex, select(0, original[dispatchIndex], s_data[0] != 0));\n`\nexport default checkSortSource;\n","import checkSortSource from '../../shaders/CheckSort';\nimport { BufferKernel } from '../radix-sort/RadixSortBufferKernel';\nimport { AbstractCheckSortKernel, AbstractCheckSortKernelOptions } from './AbstractCheckSortKernel';\n\nexport interface CheckSortBufferKernelOptions extends AbstractCheckSortKernelOptions<BufferKernel> {\n}\n\nexport class CheckSortBufferKernel extends AbstractCheckSortKernel<BufferKernel> {\n  public outputs: Array<GPUBuffer> = [];\n\n  constructor(options: CheckSortBufferKernelOptions) {\n    super(options);\n\n    this.buffers.data = options.data.keys;\n\n    this.createPassesRecursive(options.data, this.count);\n  }\n\n  createPassesRecursive(data: BufferKernel, count: number, passIndex: number = 0) {\n    const workgroupCount = Math.ceil(count / this.threadsPerWorkgroup);\n\n    const isFirstPass = !passIndex;\n    const isLastPass = workgroupCount <= 1;\n\n    const label = `check-sort-${this.mode}-${passIndex}`;\n\n    const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\n      label,\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        // Last pass bindings\n        ...(isLastPass ? [{\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        }, {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType }\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: data.keys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outputBuffer },\n        },\n        // Last pass buffers\n        ...(isLastPass ? [{\n          binding: 2,\n          resource: { buffer: this.buffers.original },\n        }, {\n          binding: 3,\n          resource: { buffer: this.buffers.isSorted },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const elementCount = isFirstPass ? this.start + count : count;\n    const startElement = isFirstPass ? this.start : 0;\n\n    const checkSortPipeline = this.device.createComputePipeline({\n      layout: pipelineLayout,\n      compute: {\n        module: this.device.createShaderModule({\n          label,\n          code: checkSortSource(isFirstPass, isLastPass, this.mode, 'buffer'),\n        }),\n        entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\n        constants: {\n          'ELEMENT_COUNT': elementCount,\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          ...(this.mode !== 'reset' && {\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'START_ELEMENT': startElement,\n          }),\n        },\n      },\n    });\n\n    this.outputs.push(outputBuffer);\n    this.pipelines.push({ pipeline: checkSortPipeline, bindGroup });\n\n    if (!isLastPass) {\n      this.createPassesRecursive({ keys: outputBuffer }, workgroupCount, passIndex + 1);\n    }\n  }\n}","import { AbstractRadixSortKernel, DispatchData, type AbstractRadixSortKernelOptions } from './AbstractRadixSortKernel';\nimport radixSortSource from '../../shaders/RadixSort';\nimport radixSortSourceLocalShuffle from '../../shaders/optimizations/RadixSortLocalShuffle';\nimport reorderSource from '../../shaders/RadixSortReorder';\nimport { findOptimalDispatchSize, removeValues } from '../../utils';\nimport { KernelPipelineDefinition } from '../AbstractKernel';\nimport { CheckSortBufferKernel } from '../check-sort/CheckSortBufferKernel';\n\nexport interface BufferKernel {\n  keys: GPUBuffer;\n  values?: GPUBuffer;\n}\n\nexport interface RadixSortKernelOptions extends AbstractRadixSortKernelOptions<BufferKernel> {\n  localShuffle?: boolean;\n}\n\nexport class RadixSortBufferKernel extends AbstractRadixSortKernel<BufferKernel> {\n  declare localShuffle: boolean;\n\n  constructor(options: RadixSortKernelOptions) {\n    super(options);\n    this.localShuffle = options.localShuffle ?? false;\n\n    this.buffers.keys = options.data.keys;\n    if (options.data.values) {\n      this.buffers.values = options.data.values;\n    }\n\n    this.createShaderModules();\n    this.createPipelines();\n  }\n\n  get hasValues(): boolean {\n    return !!this.data.values;\n  }\n\n  protected get blockSumSource(): string {\n    const source = this.localShuffle\n      ? radixSortSourceLocalShuffle\n      : radixSortSource('buffer')\n    ;\n    return this.hasValues ? source : removeValues(source);\n  }\n\n  protected get reorderSource(): string {\n    return this.hasValues ? reorderSource('buffer') : removeValues(reorderSource('buffer'));\n  }\n\n  protected createResources(): void {\n    // Keys and values double buffering\n    this.buffers.tmpKeys = this.device.createBuffer({\n      label: 'radix-sort-tmp-keys',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    if (this.hasValues) {\n      this.buffers.tmpValues = this.device.createBuffer({\n        label: 'radix-sort-tmp-values',\n        size: this.count * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n      });\n    }\n\n    // Local Prefix Sum buffer (1 element per item)\n    this.buffers.localPrefixSum = this.device.createBuffer({\n      label: 'radix-sort-local-prefix-sum',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n  }\n\n  protected getPassInData(even: boolean): BufferKernel {\n    return {\n      keys: even ? this.buffers.keys : this.buffers.tmpKeys,\n      values: even ? this.buffers.values : this.buffers.tmpValues,\n    };\n  }\n\n  protected getPassOutData(even: boolean): BufferKernel {\n    return {\n      keys: even ? this.buffers.tmpKeys : this.buffers.keys,\n      values: even ? this.buffers.tmpValues : this.buffers.values,\n    };\n  }\n\n  protected createBlockSumPipeline(inData: BufferKernel, bit: number): KernelPipelineDefinition {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-block-sum',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type: this.localShuffle\n              ? 'storage' as GPUBufferBindingType\n              : 'read-only-storage' as GPUBufferBindingType,\n          }\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inData.keys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: this.buffers.localPrefixSum },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n        // \"Local shuffle\" optimization needs access to the values buffer\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          resource: { buffer: inData.values! },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const blockSumPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-block-sum',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.blockSum,\n        entryPoint: 'radix_sort',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: blockSumPipeline,\n      bindGroup,\n    };\n  }\n\n  protected createCheckSortKernels(dispatchData: DispatchData) {\n    if (!this.checkOrder) return;\n\n    const { checkSortFastCount, checkSortFullCount, startFull } = dispatchData;\n\n    // Create the full pass\n    this.kernels.checkSortFull = new CheckSortBufferKernel({\n      mode: 'full',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.dispatchSize,\n      original: this.buffers.originalDispatchSize,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFullCount,\n      start: startFull,\n      workgroupSize: this.workgroupSize,\n    });\n\n    // Create the fast pass\n    this.kernels.checkSortFast = new CheckSortBufferKernel({\n      mode: 'fast',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.checkSortFullDispatchSize,\n      original: this.buffers.originalCheckSortFullDispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: checkSortFastCount,\n      workgroupSize: this.workgroupSize,\n    });\n\n    const initialDispatchElementCount = this.initialDispatch.length / 3;\n\n    if (this.kernels.checkSortFast!.threadsPerWorkgroup < this.kernels.checkSortFull!.pipelines.length || this.kernels.checkSortFull!.threadsPerWorkgroup < initialDispatchElementCount) {\n      console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`);\n      this.checkOrder = false;\n      return;\n    }\n\n    // Create the reset pass\n    this.kernels.checkSortReset = new CheckSortBufferKernel({\n      mode: 'reset',\n      device: this.device,\n      data: this.data,\n      original: this.buffers.originalDispatchSize,\n      result: this.buffers.dispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: initialDispatchElementCount,\n      workgroupSize: findOptimalDispatchSize(this.device, initialDispatchElementCount),\n    });\n  }\n\n  protected createReorderPipeline(inData: BufferKernel, outData: BufferKernel, bit: number): KernelPipelineDefinition {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-reorder',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n          },\n          {\n            binding: 5,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'storage' as GPUBufferBindingType },\n          },\n        ] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inData.keys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outData.keys },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.localPrefixSum },\n        },\n        {\n          binding: 3,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            resource: { buffer: inData.values! },\n          },\n          {\n            binding: 5,\n            resource: { buffer: outData.values! },\n          },\n        ] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const reorderPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-reorder',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.reorder,\n        entryPoint: 'radix_sort_reorder',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: reorderPipeline,\n      bindGroup,\n    };\n  }\n}\n","import checkSortSource from '../../shaders/CheckSort';\nimport type { TextureKernel } from '../radix-sort/RadixSortTextureKernel';\nimport { bufferToTexture } from '../../utils';\nimport { AbstractCheckSortKernel, type AbstractCheckSortKernelOptions } from './AbstractCheckSortKernel';\n\nexport interface CheckSortTextureKernelOptions extends AbstractCheckSortKernelOptions<TextureKernel> {\n}\n\nexport class CheckSortTextureKernel extends AbstractCheckSortKernel<TextureKernel> {\n  public textures: Record<string, GPUTexture> = {};\n\n  public outputs: Array<GPUTexture> = [];\n\n  constructor(options: CheckSortTextureKernelOptions) {\n    super(options);\n\n    this.textures.read = options.data.texture;\n\n    this.createPassesRecursive(options.data, this.count);\n  }\n\n  createPassesRecursive(data: TextureKernel, count: number, passIndex: number = 0) {\n    const workgroupCount = Math.ceil(count / this.threadsPerWorkgroup);\n\n    const isFirstPass = !passIndex;\n    const isLastPass = workgroupCount <= 1;\n\n    const label = `check-sort-${this.mode}-${passIndex}`;\n\n    const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\n      label,\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const outputTexture = bufferToTexture(this.device, outputBuffer);\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-write',\n            format: 'r32uint',\n            viewDimension: '2d',\n          },\n        },\n        // Last pass bindings\n        ...(isLastPass ? [{\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        }, {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType }\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: data.texture.createView(),\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n        // Last pass buffers\n        ...(isLastPass ? [{\n          binding: 2,\n          resource: { buffer: this.buffers.original },\n        }, {\n          binding: 3,\n          resource: { buffer: this.buffers.isSorted },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const elementCount = isFirstPass ? this.start + count : count;\n    const startElement = isFirstPass ? this.start : 0;\n\n    const checkSortPipeline = this.device.createComputePipeline({\n      layout: pipelineLayout,\n      compute: {\n        module: this.device.createShaderModule({\n          label,\n          code: checkSortSource(isFirstPass, isLastPass, this.mode, 'texture'),\n        }),\n        entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\n        constants: {\n          'ELEMENT_COUNT': elementCount,\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          ...(this.mode !== 'reset' && {\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'START_ELEMENT': startElement,\n          }),\n        },\n      },\n    });\n\n    this.outputs.push(outputTexture);\n    this.pipelines.push({ pipeline: checkSortPipeline, bindGroup });\n\n    if (!isLastPass) {\n      this.createPassesRecursive({ texture: outputTexture }, workgroupCount, passIndex + 1);\n    }\n  }\n}","import { AbstractRadixSortKernel, type DispatchData, type AbstractRadixSortKernelOptions } from './AbstractRadixSortKernel';\nimport radixSortSource from '../../shaders/RadixSort';\nimport reorderSource from '../../shaders/RadixSortReorder';\nimport type { KernelPipelineDefinition } from '../AbstractKernel';\nimport { CheckSortTextureKernel } from '../check-sort/CheckSortTextureKernel';\nimport { findOptimalDispatchSize } from '../../utils';\n\nexport interface TextureKernel {\n  texture: GPUTexture;\n}\n\nexport interface RadixSortKernelOptions extends AbstractRadixSortKernelOptions<TextureKernel> {\n}\n\nexport class RadixSortTextureKernel extends AbstractRadixSortKernel<TextureKernel> {\n  public textures: Record<string, GPUTexture> = {};\n\n  constructor(options: RadixSortKernelOptions) {\n    super(options);\n\n    this.textures.read = options.data.texture;\n\n    this.createShaderModules();\n    this.createPipelines();\n  }\n\n  get hasValues(): boolean {\n    return true;\n  }\n\n  protected get blockSumSource(): string {\n    return radixSortSource('texture');\n  }\n\n  protected get reorderSource(): string {\n    return reorderSource('texture');\n  }\n\n  protected createResources(): void {\n    // Write texture\n    this.textures.write = this.device.createTexture({\n      size: {\n        width: this.textures.read.width,\n        height: this.textures.read.height,\n      },\n      format: this.textures.read.format,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n    });\n\n    // Local Prefix Sum texture\n    this.textures.localPrefixSum = this.device.createTexture({\n      size: {\n        width: this.textures.read.width,\n        height: this.textures.read.height,\n      },\n      format: 'r32uint',\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n    });\n  }\n\n  protected getPassInData(even: boolean): TextureKernel {\n    return {\n      texture: even ? this.textures.read : this.textures.write,\n    };\n  }\n\n  protected getPassOutData(even: boolean): TextureKernel {\n    return {\n      texture: even ? this.textures.write : this.textures.read,\n    };\n  }\n\n  protected createBlockSumPipeline(inData: TextureKernel, bit: number) {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-block-sum',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'write-only',\n            format: 'r32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: inData.texture.createView(),\n        },\n        {\n          binding: 1,\n          resource: this.textures.localPrefixSum.createView(),\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const blockSumPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-block-sum',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.blockSum,\n        entryPoint: 'radix_sort',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: blockSumPipeline,\n      bindGroup,\n    };\n  }\n\n  protected createCheckSortKernels(dispatchData: DispatchData) {\n    if (!this.checkOrder) return;\n\n    const { checkSortFastCount, checkSortFullCount, startFull } = dispatchData;\n\n    // Create the full pass\n    this.kernels.checkSortFull = new CheckSortTextureKernel({\n      mode: 'full',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.dispatchSize,\n      original: this.buffers.originalDispatchSize,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFullCount,\n      start: startFull,\n      workgroupSize: this.workgroupSize,\n    });\n\n    // Create the fast pass\n    this.kernels.checkSortFast = new CheckSortTextureKernel({\n      mode: 'fast',\n      device: this.device,\n      data: this.data,\n      result: this.buffers.checkSortFullDispatchSize,\n      original: this.buffers.originalCheckSortFullDispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: checkSortFastCount,\n      workgroupSize: this.workgroupSize,\n    });\n\n    const initialDispatchElementCount = this.initialDispatch.length / 3;\n\n    if (this.kernels.checkSortFast!.threadsPerWorkgroup < this.kernels.checkSortFull!.pipelines.length || this.kernels.checkSortFull!.threadsPerWorkgroup < initialDispatchElementCount) {\n      console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`);\n      this.checkOrder = false;\n      return;\n    }\n\n    // Create the reset pass\n    this.kernels.checkSortReset = new CheckSortTextureKernel({\n      mode: 'reset',\n      device: this.device,\n      data: this.data,\n      original: this.buffers.originalDispatchSize,\n      result: this.buffers.dispatchSize,\n      isSorted: this.buffers.isSorted,\n      count: initialDispatchElementCount,\n      workgroupSize: findOptimalDispatchSize(this.device, initialDispatchElementCount),\n    });\n  }\n\n  protected createReorderPipeline(inData: TextureKernel, outData: TextureKernel, bit: number): KernelPipelineDefinition {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-reorder',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'write-only',\n            format: 'rg32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-write',\n            format: 'r32uint',\n            viewDimension: '2d',\n          },\n        },\n        {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: inData.texture.createView(),\n        },\n        {\n          binding: 1,\n          resource: outData.texture.createView(),\n        },\n        {\n          binding: 2,\n          resource: this.textures.localPrefixSum.createView(),\n        },\n        {\n          binding: 3,\n          resource: { buffer: this.buffers.prefixBlockSum },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const reorderPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-reorder',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.reorder,\n        entryPoint: 'radix_sort_reorder',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: reorderPipeline,\n      bindGroup,\n    };\n  }\n}\n"],"names":["AbstractKernel","options","key","val","findOptimalDispatchSize","device","workgroupCount","dispatchSize","x","y","createBufferFromData","label","data","usage","dispatchSizes","bufferToTexture","buffer","TEXTURE_WIDTH","TEXTURE_HEIGHT","texture","command","removeValues","source","line","prefixSumSource","prefixSumSourceNoBankConflict","PrefixSumKernel","count","workgroupSize","avoidBankConflicts","blockSumBuffer","bindGroupLayout","bindGroup","pipelineLayout","scanPipeline","blockSumPipeline","p","pass","dispatchSizeBuffer","offset","pipeline","i","AbstractCheckSortKernel","itemCount","threadsPerWorkgroup","sizes","targetWorkgroupCount","dispatchIndirect","AbstractRadixSortKernel","#createPrefixSumKernel","dispatchData","#calculateDispatchSizes","#createCheckSortBuffers","bit","even","inData","outData","reorderPipeline","prefixBlockSumBuffer","prefixSumKernel","prefixSumDispatchSize","checkSortFastCount","checkSortFullCount","startFull","dispatchSizesFast","dispatchSizesFull","initialDispatch","#dispatchPipelinesIndirect","#dispatchPipelines","radixSortSource","dataType","radixSortSourceLocalShuffle","reorderSource","checkSortSource","isFirstPass","isLastPass","kernelMode","first_pass_load_data","last_pass","write_reduction_result","last_pass_full","last_pass_fast","CheckSortBufferKernel","passIndex","outputBuffer","elementCount","startElement","checkSortPipeline","RadixSortBufferKernel","initialDispatchElementCount","CheckSortTextureKernel","outputTexture","RadixSortTextureKernel"],"mappings":"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"}