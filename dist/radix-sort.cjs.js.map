{"version":3,"file":"radix-sort.cjs.js","sources":["../src/utils.ts","../src/shaders/PrefixSum.ts","../src/shaders/optimizations/PrefixSumNoBankConflict.ts","../src/AbstractKernel.ts","../src/PrefixSumKernel.ts","../src/shaders/CheckSort.ts","../src/CheckSortKernel.ts","../src/shaders/RadixSort.ts","../src/shaders/optimizations/RadixSortLocalShuffle.ts","../src/shaders/RadixSortReorder.ts","../src/RadixSortKernel.ts"],"sourcesContent":["export type WorkgroupSize = {\n  x: number;\n  y: number;\n}\n\nexport type DispatchSize = WorkgroupSize;\n\n/**\n * Find the best dispatch size x and y dimensions to minimize unused workgroups\n * \n * @param {GPUDevice} device - The GPU device\n * @param {int} workgroupCount - Number of workgroups to dispatch\n * @returns \n */\nexport function findOptimalDispatchSize(device: GPUDevice, workgroupCount: number) {\n  const dispatchSize = { \n    x: workgroupCount, \n    y: 1,\n  };\n\n  if (workgroupCount > device.limits.maxComputeWorkgroupsPerDimension) {\n    const x = Math.floor(Math.sqrt(workgroupCount));\n    const y = Math.ceil(workgroupCount / x);\n\n    dispatchSize.x = x;\n    dispatchSize.y = y;\n  }\n\n  return dispatchSize;\n}\n\nexport function createBufferFromData({ device, label, data, usage = 0 }: {\n  device: GPUDevice,\n  label: string,\n  data: number[],\n  usage: number,\n}) {\n  const dispatchSizes = device.createBuffer({\n    label,\n    usage,\n    size: data.length * 4,\n    mappedAtCreation: true,\n  });\n\n  const dispatchData = new Uint32Array(dispatchSizes.getMappedRange());\n  dispatchData.set(data);\n  dispatchSizes.unmap();\n\n  return dispatchSizes;\n}","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  temp[ELM_TID]      = select(items[ELM_GID], 0u, ELM_GID >= ELEMENT_COUNT);\n  temp[ELM_TID + 1u] = select(items[ELM_GID + 1u], 0u, ELM_GID + 1u >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n    // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    let last_offset = ITEMS_PER_WORKGROUP - 1u;\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (ELM_GID >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID] = temp[ELM_TID];\n\n  if (ELM_GID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n  items[ELM_GID + 1u] = temp[ELM_TID + 1u];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nconst NUM_BANKS: u32 = 32u;\nconst LOG_NUM_BANKS: u32 = 5u;\n\nfn get_offset(offset: u32) -> u32 {\n  // return offset >> LOG_NUM_BANKS; // Conflict-free\n  return (offset >> NUM_BANKS) + (offset >> (2u * LOG_NUM_BANKS)); // Zero bank conflict\n}\n\nvar<workgroup> temp: array<u32, 2u * ITEMS_PER_WORKGROUP>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_TID = TID * 2u; // Element pair local ID\n  let ELM_GID = GID * 2u; // Element pair global ID\n\n  // Load input to shared memory\n  let ai: u32 = TID;\n  let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1u);\n  let s_ai = ai + get_offset(ai);\n  let s_bi = bi + get_offset(bi);\n  let g_ai = ai + WID * 2u;\n  let g_bi = bi + WID * 2u;\n  temp[s_ai] = select(items[g_ai], 0u, g_ai >= ELEMENT_COUNT);\n  temp[s_bi] = select(items[g_bi], 0u, g_bi >= ELEMENT_COUNT);\n\n  var offset: u32 = 1u;\n\n  // Up-sweep (reduce) phase\n  for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n      temp[bi] += temp[ai];\n    }\n\n    offset *= 2u;\n  }\n\n  // Save workgroup sum and clear last element\n  if (TID == 0u) {\n    var last_offset = ITEMS_PER_WORKGROUP - 1u;\n    last_offset += get_offset(last_offset);\n\n    blockSums[WORKGROUP_ID] = temp[last_offset];\n    temp[last_offset] = 0u;\n  }\n\n  // Down-sweep phase\n  for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {\n    offset >>= 1u;\n    workgroupBarrier();\n\n    if (TID < d) {\n      var ai: u32 = offset * (ELM_TID + 1u) - 1u;\n      var bi: u32 = offset * (ELM_TID + 2u) - 1u;\n      ai += get_offset(ai);\n      bi += get_offset(bi);\n\n      let t: u32 = temp[ai];\n      temp[ai] = temp[bi];\n      temp[bi] += t;\n    }\n  }\n  workgroupBarrier();\n\n  // Copy result from shared memory to global memory\n  if (g_ai < ELEMENT_COUNT) {\n    items[g_ai] = temp[s_ai];\n  }\n  if (g_bi < ELEMENT_COUNT) {\n    items[g_bi] = temp[s_bi];\n  }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  let ELM_ID = GID * 2u;\n\n  if (ELM_ID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  let blockSum = blockSums[WORKGROUP_ID];\n\n  items[ELM_ID] += blockSum;\n\n  if (ELM_ID + 1u >= ELEMENT_COUNT) {\n    return;\n  }\n\n  items[ELM_ID + 1u] += blockSum;\n}\n`;\n","import type { DispatchSize, WorkgroupSize } from './utils';\n\nexport interface IAbstractKernelOptions {\n  device: GPUDevice;\n  count: number;\n  workgroupSize?: WorkgroupSize;\n}\n\ninterface IKernelPipelineDefinition {\n  pipeline: GPUComputePipeline;\n  bindGroup: GPUBindGroup;\n  dispatchSize?: DispatchSize;\n}\n\nexport abstract class AbstractKernel {\n  public device: GPUDevice;\n\n  public count: number;\n\n  public workgroupSize: WorkgroupSize;\n\n  public pipelines: Array<IKernelPipelineDefinition> = [];\n\n  protected shaderModules: Record<string, GPUShaderModule> = {};\n\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n  }: IAbstractKernelOptions) {\n    this.device = device;\n    this.count = count;\n    this.workgroupSize = workgroupSize;\n  }\n\n  get workgroupCount(): number {\n    return Math.ceil(this.count / this.threadsPerWorkgroup);\n  }\n\n  get threadsPerWorkgroup(): number {\n    return this.workgroupSize.x * this.workgroupSize.y\n  }\n\n  get itemsPerWorkgroup(): number {\n    return 2 * this.threadsPerWorkgroup;\n  }\n\n  abstract dispatch(passEncoder: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset?: number): void;\n}\n","import { findOptimalDispatchSize } from './utils';\nimport type { WorkgroupSize, DispatchSize } from './utils';\nimport prefixSumSource from './shaders/PrefixSum';\nimport prefixSumSourceNoBankConflict from './shaders/optimizations/PrefixSumNoBankConflict';\nimport { AbstractKernel, type IAbstractKernelOptions } from './AbstractKernel';\n\ninterface IPrefixSumKernelOptions extends IAbstractKernelOptions {\n  data: GPUBuffer;\n  avoidBankConflicts?: boolean;\n}\n\nexport class PrefixSumKernel extends AbstractKernel {\n  /**\n   * Perform a parallel prefix sum on the given data buffer\n   * \n   * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\n   * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - Max number of elements to process\n   * @param {WorkgroupSize} workgroupSize - Workgroup size in x and y dimensions. (x * y) must be a power of two\n   * @param {GPUBuffer} data - Buffer containing the data to process\n   * @param {boolean} avoidBankConflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    data,\n    avoidBankConflicts = false\n  }: IPrefixSumKernelOptions) {\n    super({ device, count, workgroupSize });\n\n    if (Math.log2(this.threadsPerWorkgroup) % 1 !== 0) {\n      throw new Error(`workgroupSize.x * workgroupSize.y must be a power of two. (current: ${this.threadsPerWorkgroup})`);\n    }\n\n    this.shaderModules.prefixSum = this.device.createShaderModule({\n      label: 'prefix-sum',\n      code: avoidBankConflicts ? prefixSumSourceNoBankConflict : prefixSumSource,\n    })\n\n    this.createPassRecursive(data, count);\n  }\n\n  createPassRecursive(data: GPUBuffer, count: number) {\n    // Find best dispatch x and y dimensions to minimize unused threads\n    const workgroupCount = Math.ceil(count / this.itemsPerWorkgroup);\n    const dispatchSize = findOptimalDispatchSize(this.device, workgroupCount);\n\n    // Create buffer for block sums\n    const blockSumBuffer = this.device.createBuffer({\n      label: 'prefix-sum-block-sum',\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create bind group and pipeline layout\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      label: 'prefix-sum-bind-group',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: data },\n        },\n        {\n          binding: 1,\n          resource: { buffer: blockSumBuffer },\n        },\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [ bindGroupLayout ],\n    });\n\n    // Per-workgroup (block) prefix sum\n    const scanPipeline = this.device.createComputePipeline({\n      label: 'prefix-sum-scan-pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.prefixSum,\n        entryPoint: 'reduce_downsweep',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ITEMS_PER_WORKGROUP': this.itemsPerWorkgroup,\n          'ELEMENT_COUNT': count,\n        },\n      },\n    });\n\n    this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize });\n\n    if (workgroupCount > 1) {\n      // Prefix sum on block sums\n      this.createPassRecursive(blockSumBuffer, workgroupCount);\n\n      // Add block sums to local prefix sums\n      const blockSumPipeline = this.device.createComputePipeline({\n        label: 'prefix-sum-add-block-pipeline',\n        layout: pipelineLayout,\n        compute: {\n          module: this.shaderModules.prefixSum,\n          entryPoint: 'add_block_sums',\n          constants: {\n            'WORKGROUP_SIZE_X': this.workgroupSize.x,\n            'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'ELEMENT_COUNT': count,\n          },\n        },\n      });\n\n      this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize });\n    }\n  }\n\n  getDispatchChain() {\n    return this.pipelines.flatMap((p) => [ p.dispatchSize!.x, p.dispatchSize!.y, 1 ]);\n  }\n\n  /**\n   * Encode the prefix sum pipeline into the current pass.\n   * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\n   *\n   * @param {GPUComputePassEncoder} pass\n   * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\n   * @param {number} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\n   */\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup, dispatchSize }, i) => {\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (!dispatchSizeBuffer) {\n        pass.dispatchWorkgroups(dispatchSize!.x, dispatchSize!.y, 1);\n      } else {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      }\n    });\n  }\n}\n","const checkSortSource = (isFirstPass = false, isLastPass = false, kernelMode = 'full') => /* wgsl */ `\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\n@group(0) @binding(2) var<storage, read> original: array<u32>;\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\noverride START_ELEMENT: u32;\n\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\n\n// Reset dispatch buffer and is_sorted flag\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reset(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  if (TID >= ELEMENT_COUNT) {\n    return;\n  }\n\n  if (TID == 0) {\n    is_sorted = 0u;\n  }\n\n  let ELM_ID = TID * 3;\n\n  output[ELM_ID] = original[ELM_ID];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn check_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\n  let GID = TID + WID; // Global thread ID\n\n  // Load data into shared memory\n  ${ isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, input[GID], GID < ELEMENT_COUNT);\" }\n\n  // Perform parallel reduction\n  for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {\n    workgroupBarrier();  \n    if (TID % (2u * d) == 0u) {\n      s_data[TID] += s_data[TID + d];\n    }\n  }\n  workgroupBarrier();\n\n  // Write reduction result\n  ${ isLastPass ? last_pass(kernelMode) : write_reduction_result }\n}`\n\nconst write_reduction_result = /* wgsl */ `\n  if (TID == 0) {\n    output[WORKGROUP_ID] = s_data[0];\n  }\n`\n\nconst first_pass_load_data = /* wgsl */ `\n  let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\n\n  // Load current element into shared memory\n  // Also load next element for comparison\n  let elm = select(0u, input[GID], GID < ELEMENT_COUNT);\n  let next = select(0u, input[GID + 1], GID < ELEMENT_COUNT-1);\n  s_data[TID] = elm;\n  workgroupBarrier();\n\n  s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\n`\n\nconst last_pass = (kernelMode: string) => /* wgsl */ `\n  let fullDispatchLength = arrayLength(&output);\n  let dispatchIndex = TID * 3;\n\n  if (dispatchIndex >= fullDispatchLength) {\n    return;\n  }\n\n  ${kernelMode == 'full' ? last_pass_full : last_pass_fast}\n`\n\n// If the fast check kernel is sorted and the data isn't already sorted, run the full check\nconst last_pass_fast = /* wgsl */ `\n  output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u);\n`\n\n// If the full check kernel is sorted, set the flag to 1 and skip radix sort passes\nconst last_pass_full = /* wgsl */ `\n  if (TID == 0 && s_data[0] == 0) {\n    is_sorted = 1u;\n  }\n\n  output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] != 0);\n`\nexport default checkSortSource;\n","import { findOptimalDispatchSize } from './utils';\nimport type { WorkgroupSize } from './utils';\nimport checkSortSource from './shaders/CheckSort';\nimport { AbstractKernel, type IAbstractKernelOptions } from './AbstractKernel';\n\ninterface ICheckSortKernelOptions extends IAbstractKernelOptions {\n  data: GPUBuffer;\n  result: GPUBuffer;\n  original: GPUBuffer;\n  isSorted: GPUBuffer;\n  start?: number;\n  mode?: 'full' | 'fast' | 'reset';\n}\n\nexport class CheckSortKernel extends AbstractKernel {\n  public start: number;\n\n  public mode: 'full' | 'fast' | 'reset';\n\n  private buffers: Record<string, GPUBuffer> = {};\n\n  public outputs: Array<GPUBuffer> = [];\n\n  /**\n   * CheckSortKernel - Performs a parralel reduction to check if an array is sorted.\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - The number of elements to check\n   * @param {WorkgroupSize} workgroupSize - The workgroup size in x and y dimensions\n   * @param {GPUBuffer} data - The buffer containing the data to check\n   * @param {GPUBuffer} result - The result dispatch size buffer\n   * @param {GPUBuffer} original - The original dispatch size buffer\n   * @param {GPUBuffer} isSorted - 1-element buffer to store whether the array is sorted\n   * @param {number} start - The index to start checking from\n   * @param {boolean} mode - The type of check sort kernel ('reset', 'fast', 'full')\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    data,\n    result,\n    original,\n    isSorted,\n    start = 0,\n    mode = 'full',\n  }: ICheckSortKernelOptions) {\n    super({ device, count, workgroupSize });\n    this.start = start;\n    this.mode = mode;\n\n    this.buffers = {\n      data,\n      result,\n      original,\n      isSorted,\n    };\n\n    this.createPassesRecursive(data, count);\n  }\n\n  // Find the best dispatch size for each pass to minimize unused workgroups\n  static findOptimalDispatchChain(device: GPUDevice, itemCount: number, workgroupSize: WorkgroupSize) {\n    const threadsPerWorkgroup = workgroupSize.x * workgroupSize.y;\n    const sizes = [];\n\n    do {\n      // Number of workgroups required to process all items\n      const targetWorkgroupCount = Math.ceil(itemCount / threadsPerWorkgroup);\n\n      // Optimal dispatch size and updated workgroup count\n      const dispatchSize = findOptimalDispatchSize(device, targetWorkgroupCount);\n\n      sizes.push(dispatchSize.x, dispatchSize.y, 1);\n      itemCount = targetWorkgroupCount;\n    } while (itemCount > 1);\n\n    return sizes;\n  }\n\n  createPassesRecursive(buffer: GPUBuffer, count: number, passIndex: number = 0) {\n    const workgroupCount = Math.ceil(count / this.threadsPerWorkgroup);\n\n    const isFirstPass = passIndex === 0;\n    const isLastPass = workgroupCount <= 1;\n\n    const label = `check-sort-${this.mode}-${passIndex}`;\n\n    const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\n      label: label,\n      size: workgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        // Last pass bindings\n        ...(isLastPass ? [{\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        }, {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType }\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: buffer },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outputBuffer },\n        },\n        // Last pass buffers\n        ...(isLastPass ? [{\n          binding: 2,\n          resource: { buffer: this.buffers.original },\n        }, {\n          binding: 3,\n          resource: { buffer: this.buffers.isSorted },\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const elementCount = isFirstPass ? this.start + count : count;\n    const startElement = isFirstPass ? this.start : 0;\n\n    const checkSortPipeline = this.device.createComputePipeline({\n      layout: pipelineLayout,\n      compute: {\n        module: this.device.createShaderModule({\n          label: label,\n          code: checkSortSource(isFirstPass, isLastPass, this.mode),\n        }),\n        entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\n        constants: {\n          'ELEMENT_COUNT': elementCount,\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          ...(this.mode !== 'reset' && {\n            'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n            'START_ELEMENT': startElement,\n          }),\n        },\n      },\n    });\n\n    this.outputs.push(outputBuffer);\n    this.pipelines.push({ pipeline: checkSortPipeline, bindGroup });\n\n    if (!isLastPass) {\n      this.createPassesRecursive(outputBuffer, workgroupCount, passIndex + 1);\n    }\n  }\n\n  dispatch(pass: GPUComputePassEncoder, dispatchSizeBuffer?: GPUBuffer, offset: number = 0) {\n    this.pipelines.forEach(({ pipeline, bindGroup }, i) => {\n      const dispatchIndirect = this.mode !== 'reset' && (this.mode === 'full' || i < this.pipelines.length - 1);\n\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n\n      if (dispatchIndirect && dispatchSizeBuffer) {\n        pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n      } else {\n        // Only the reset kernel and the last dispatch of the fast check kernel are constant to (1, 1, 1)\n        pass.dispatchWorkgroups(1, 1, 1);\n      }\n    });\n  }\n}\n","export default `\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  let elm = select(input[GID], 0u, GID >= ELEMENT_COUNT);\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu; \n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  if (GID < ELEMENT_COUNT) {\n    // Store local prefix sum to global memory\n    local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\n  }\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2u * (THREADS_PER_WORKGROUP + 1u)>;\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  // Extract 2 bits from the input\n  var elm: u32 = 0u;\n  var val: u32 = 0u;\n  if (GID < ELEMENT_COUNT) {\n    elm = input[GID];\n    val = values[GID];\n  }\n  let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3u;\n\n  var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n  // If the workgroup is inactive, prevent block_sums buffer update\n  var LAST_THREAD: u32 = 0xffffffffu; \n\n  if (WORKGROUP_ID < WORKGROUP_COUNT) {\n    // Otherwise store the index of the last active thread in the workgroup\n    LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1u;\n  }\n\n  // Initialize parameters for double-buffering\n  let TPW = THREADS_PER_WORKGROUP + 1u;\n  var swapOffset: u32 = 0u;\n  var inOffset:  u32 = TID;\n  var outOffset: u32 = TID + TPW;\n\n  // 4-way prefix sum\n  for (var b: u32 = 0u; b < 4u; b++) {\n    // Initialize local prefix with bitmask\n    let bitmask = select(0u, 1u, extract_bits == b);\n    s_prefix_sum[inOffset + 1u] = bitmask;\n    workgroupBarrier();\n\n    var prefix_sum: u32 = 0u;\n\n    // Prefix sum\n    for (var offset: u32 = 1u; offset < THREADS_PER_WORKGROUP; offset *= 2u) {\n      if (TID >= offset) {\n        prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n      } else {\n        prefix_sum = s_prefix_sum[inOffset];\n      }\n\n      s_prefix_sum[outOffset] = prefix_sum;\n\n      // Swap buffers\n      outOffset = inOffset;\n      swapOffset = TPW - swapOffset;\n      inOffset = TID + swapOffset;\n\n      workgroupBarrier();\n    }\n\n    // Store prefix sum for current bit\n    bit_prefix_sums[b] = prefix_sum;\n\n    if (TID == LAST_THREAD) {\n      // Store block sum to global memory\n      let total_sum: u32 = prefix_sum + bitmask;\n      block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n    }\n\n    // Swap buffers\n    outOffset = inOffset;\n    swapOffset = TPW - swapOffset;\n    inOffset = TID + swapOffset;\n  }\n\n  let prefix_sum = bit_prefix_sums[extract_bits];   \n\n  // Scan bit prefix sums\n  if (TID == LAST_THREAD) {\n    var sum: u32 = 0u;\n    bit_prefix_sums[extract_bits] += 1u;\n\n    for (var i: u32 = 0u; i < 4u; i++) {\n      s_prefix_sum_scan[i] = sum;\n      sum += bit_prefix_sums[i];\n    }\n  }\n  workgroupBarrier();\n\n  if (GID < ELEMENT_COUNT) {\n    // Compute new position\n    let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\n\n    // Shuffle elements locally\n    input[WID + new_pos] = elm;\n    values[WID + new_pos] = val;\n    local_prefix_sums[WID + new_pos] = prefix_sum;\n  }\n}\n`;\n","export default `\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort_reorder(\n  @builtin(workgroup_id) w_id: vec3<u32>,\n  @builtin(num_workgroups) w_dim: vec3<u32>,\n  @builtin(local_invocation_index) TID: u32, // Local thread ID\n) { \n  let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n  let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n  let GID = WID + TID; // Global thread ID\n\n  if (GID >= ELEMENT_COUNT) { return; }\n\n  let k = inputKeys[GID];\n  let v = inputValues[GID];\n\n  let local_prefix = local_prefix_sum[GID];\n\n  // Calculate new position\n  let extract_bits = (k >> CURRENT_BIT) & 0x3u;\n  let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\n  let sorted_position = prefix_block_sum[pid] + local_prefix;\n\n  outputKeys[sorted_position] = k;\n  outputValues[sorted_position] = v;\n}\n`;\n\n","import { PrefixSumKernel } from './PrefixSumKernel';\nimport { CheckSortKernel } from './CheckSortKernel';\nimport { createBufferFromData, findOptimalDispatchSize } from './utils';\nimport type {WorkgroupSize, DispatchSize } from './utils';\nimport radixSortSource from './shaders/RadixSort';\nimport radixSortSource_LocalShuffle from './shaders/optimizations/RadixSortLocalShuffle';\nimport reorderSource from './shaders/RadixSortReorder';\nimport { AbstractKernel } from './AbstractKernel';\n\ninterface IRadixSortKernelOptions {\n  device: GPUDevice;\n  count: number;\n  workgroupSize: WorkgroupSize;\n  texture?: GPUTexture;\n  keys?: GPUBuffer;\n  values?: GPUBuffer;\n  bitCount: number;\n  checkOrder?: boolean;\n  localShuffle?: boolean;\n  avoidBankConflicts?: boolean;\n}\n\ninterface IDispatchData {\n  initialDispatch: Array<number>;\n  dispatchSizesFull: Array<number>;\n  checkSortFastCount: number;\n  checkSortFullCount: number;\n  startFull: number;\n}\n\nexport class RadixSortKernel extends AbstractKernel {\n  public bitCount: number;\n\n  public checkOrder: boolean = false;\n\n  public localShuffle: boolean = false;\n\n  public avoidBankConflicts: boolean = false;\n\n  private prefixBlockWorkgroupCount: number;\n\n  private hasValues: boolean;\n\n  private dispatchSize: DispatchSize = {\n    x: 1,\n    y: 1,\n  };\n\n  private dispatchOffsets = {\n    radixSort: 0,\n    checkSortFast: 3 * 4,\n    prefixSum: 6 * 4\n  };\n\n  private initialDispatch: Array<number> = [];\n\n  private kernels: {\n    prefixSum?: PrefixSumKernel;\n    checkSort?: {\n      reset: CheckSortKernel;\n      fast: CheckSortKernel;\n      full: CheckSortKernel;\n    };\n  } = {};\n\n  public buffers: Record<string, GPUBuffer | undefined> = {};\n\n  public texture?: GPUTexture;\n\n  /**\n   * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\n   * Note: The buffers are sorted in-place.\n   * \n   * Based on \"Fast 4-way parallel radix sorting on GPUs\"\n   * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\n   * \n   * @param {GPUDevice} device\n   * @param {number} count - Number of elements to sort\n   * @param {WorkgroupSize} workgroupSize - Workgroup size in x and y dimensions. (x * y) must be a power of two\n   * @param {GPUTexture} texture - storage texture 2d rg32uint containing the pairs or [key, value] stored in a pixel\n   * @param {GPUBuffer} keys - Buffer containing the keys to sort\n   * @param {GPUBuffer} values - (optional) Buffer containing the associated values\n   * @param {number} bitCount - Number of bits per element (default: 32)\n   * @param {boolean} checkOrder - Enable \"order checking\" optimization. Can improve performance if the data needs to be sorted in real-time and doesn't change much. (default: false)\n   * @param {boolean} localShuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\n   * @param {boolean} avoidBankConflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\n   */\n  constructor({\n    device,\n    count,\n    workgroupSize = { x: 16, y: 16 },\n    texture,\n    keys,\n    values,\n    bitCount = 32,\n    checkOrder = false,\n    localShuffle = false,\n    avoidBankConflicts = false,\n  }: IRadixSortKernelOptions) {\n    super({ device, count, workgroupSize });\n    if (!device) throw new Error('No device provided');\n    if (!keys && !texture) throw new Error('No keys buffer or texture provided');\n    if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter');\n    if (!Number.isInteger(bitCount) || bitCount <= 0 || bitCount > 32) throw new Error(`Invalid bitCount parameter: ${bitCount}`);\n    if (!Number.isInteger(workgroupSize.x) || !Number.isInteger(workgroupSize.y)) throw new Error('Invalid workgroupSize parameter');\n    if (bitCount % 4 != 0) throw new Error('bitCount must be a multiple of 4');\n\n    this.bitCount = bitCount;\n    this.checkOrder = checkOrder;\n    this.localShuffle = localShuffle;\n    this.avoidBankConflicts = avoidBankConflicts;\n\n    this.prefixBlockWorkgroupCount = 4 * this.workgroupCount;\n\n    this.hasValues = !!values || !!texture; // Is the values buffer or input texture provided ?\n\n    this.texture = texture;\n    this.buffers = { keys, values }; // GPUBuffers\n\n    // Create shader modules from wgsl code\n    this.createShaderModules();\n\n    // Create multi-pass pipelines\n    this.createPipelines();\n  }\n\n  private createShaderModules() {\n    // Remove every occurence of \"values\" in the shader code if values buffer is not provided\n    const removeValues = (source: string) => source\n      .split('\\n')\n      .filter((line) => !line.toLowerCase().includes('values'))\n      .join('\\n')\n    ;\n\n    const blockSumSource = this.localShuffle ? radixSortSource_LocalShuffle : radixSortSource;\n\n    this.shaderModules = {\n      blockSum: this.device.createShaderModule({\n        label: 'radix-sort-block-sum',\n        code: this.hasValues ? blockSumSource : removeValues(blockSumSource),\n      }),\n      reorder: this.device.createShaderModule({\n        label: 'radix-sort-reorder',\n        code: this.hasValues ? reorderSource : removeValues(reorderSource),\n      }),\n    };\n  }\n\n  private createPipelines() {\n    // Block prefix sum kernel\n    this.createPrefixSumKernel();\n\n    // Indirect dispatch buffers\n    const dispatchData = this.calculateDispatchSizes();\n\n    // GPU buffers\n    this.createBuffers(dispatchData);\n\n    // Check sort kernels\n    this.createCheckSortKernels(dispatchData);\n\n    // Radix sort passes for every 2 bits\n    for (let bit = 0; bit < this.bitCount; bit += 2) {\n      // Swap buffers every pass\n      const even = (bit % 4 == 0);\n      const inKeys = even ? this.buffers.keys : this.buffers.tmpKeys;\n      const inValues = even ? this.buffers.values : this.buffers.tmpValues;\n      const outKeys = even ? this.buffers.tmpKeys : this.buffers.keys;\n      const outValues = even ? this.buffers.tmpValues : this.buffers.values;\n\n      // Compute local prefix sums and block sums\n      const blockSumPipeline = this.createBlockSumPipeline(inKeys!, inValues!, bit);\n\n      // Reorder keys and values\n      const reorderPipeline = this.createReorderPipeline(inKeys!, inValues!, outKeys!, outValues!, bit);\n\n      this.pipelines.push(blockSumPipeline, reorderPipeline);\n    }\n  }\n\n  private createPrefixSumKernel() {\n    // Prefix Block Sum buffer (4 element per workgroup)\n    const prefixBlockSumBuffer = this.device.createBuffer({\n      label: 'radix-sort-prefix-block-sum',\n      size: this.prefixBlockWorkgroupCount * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create block prefix sum kernel\n    const prefixSumKernel = new PrefixSumKernel({\n      device: this.device,\n      data: prefixBlockSumBuffer,\n      count: this.prefixBlockWorkgroupCount,\n      workgroupSize: this.workgroupSize,\n      avoidBankConflicts: this.avoidBankConflicts,\n    });\n\n    this.kernels.prefixSum = prefixSumKernel;\n    this.buffers.prefixBlockSum = prefixBlockSumBuffer;\n  }\n\n  private calculateDispatchSizes(): IDispatchData {\n    // Radix sort dispatch size\n    const dispatchSize = findOptimalDispatchSize(this.device, this.workgroupCount);\n\n    // Prefix sum dispatch sizes\n    const prefixSumDispatchSize = this.kernels.prefixSum!.getDispatchChain();\n\n    // Check sort element count (fast/full)\n    const checkSortFastCount = Math.min(this.count, this.threadsPerWorkgroup * 4);\n    const checkSortFullCount = this.count - checkSortFastCount;\n    const startFull = checkSortFastCount - 1;\n\n    // Check sort dispatch sizes\n    const dispatchSizesFast = CheckSortKernel.findOptimalDispatchChain(this.device, checkSortFastCount, this.workgroupSize);\n    const dispatchSizesFull = CheckSortKernel.findOptimalDispatchChain(this.device, checkSortFullCount, this.workgroupSize);\n\n    // Initial dispatch sizes\n    const initialDispatch = [\n      dispatchSize.x, dispatchSize.y, 1, // Radix Sort + Reorder\n      ...dispatchSizesFast.slice(0, 3),  // Check sort fast\n      ...prefixSumDispatchSize,          // Prefix Sum\n    ];\n\n    // Dispatch offsets in main buffer\n    this.dispatchOffsets = {\n      radixSort: 0,\n      checkSortFast: 3 * 4,\n      prefixSum: 6 * 4,\n    };\n\n    this.dispatchSize = dispatchSize;\n    this.initialDispatch = initialDispatch;\n\n    return {\n      initialDispatch,\n      dispatchSizesFull,\n      checkSortFastCount,\n      checkSortFullCount,\n      startFull,\n    };\n  }\n\n  private createBuffers(dispatchData: IDispatchData) {\n    // Keys and values double buffering\n    const tmpKeysBuffer = this.device.createBuffer({\n      label: 'radix-sort-tmp-keys',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const tmpValuesBuffer = !this.hasValues ? undefined : this.device.createBuffer({\n      label: 'radix-sort-tmp-values',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Local Prefix Sum buffer (1 element per item)\n    const localPrefixSumBuffer = this.device.createBuffer({\n      label: 'radix-sort-local-prefix-sum',\n      size: this.count * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    this.buffers.tmpKeys = tmpKeysBuffer;\n    this.buffers.tmpValues = tmpValuesBuffer;\n    this.buffers.localPrefixSum = localPrefixSumBuffer;\n\n    // Only create indirect dispatch buffers when checkOrder optimization is enabled\n    if (!this.checkOrder) {\n      return;\n    }\n\n    // Dispatch sizes (radix sort, check sort, prefix sum)\n    const dispatchBuffer = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    const originalDispatchBuffer = createBufferFromData({\n      device: this.device,\n      label: 'radix-sort-dispatch-size-original',\n      data: dispatchData.initialDispatch,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Dispatch sizes (full sort)\n    const checkSortFullDispatchBuffer = createBufferFromData({\n      label: 'check-sort-full-dispatch-size',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    const checkSortFullOriginalDispatchBuffer = createBufferFromData({\n      label: 'check-sort-full-dispatch-size-original',\n      device: this.device,\n      data: dispatchData.dispatchSizesFull,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Flag to tell if the data is sorted\n    const isSortedBuffer = createBufferFromData({\n      label: 'is-sorted',\n      device: this.device,\n      data: [0],\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    this.buffers.dispatchSize = dispatchBuffer;\n    this.buffers.originalDispatchSize = originalDispatchBuffer;\n    this.buffers.checkSortFullDispatchSize = checkSortFullDispatchBuffer;\n    this.buffers.originalCheckSortFullDispatchSize = checkSortFullOriginalDispatchBuffer;\n    this.buffers.isSorted = isSortedBuffer;\n  }\n\n  private createCheckSortKernels(checkSortPartitionData: IDispatchData) {\n    if (!this.checkOrder) {\n      return;\n    }\n\n    const { checkSortFastCount, checkSortFullCount, startFull } = checkSortPartitionData\n\n    // Create the full pass\n    const checkSortFull = new CheckSortKernel({\n      mode: 'full',\n      device: this.device,\n      data: this.buffers.keys!,\n      result: this.buffers.dispatchSize!,\n      original: this.buffers.originalDispatchSize!,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFullCount,\n      start: startFull,\n      workgroupSize: this.workgroupSize,\n    });\n\n    // Create the fast pass\n    const checkSortFast = new CheckSortKernel({\n      mode: 'fast',\n      device: this.device,\n      data: this.buffers.keys!,\n      result: this.buffers.checkSortFullDispatchSize!,\n      original: this.buffers.originalCheckSortFullDispatchSize!,\n      isSorted: this.buffers.isSorted!,\n      count: checkSortFastCount,\n      workgroupSize: this.workgroupSize,\n    });\n\n    const initialDispatchElementCount = this.initialDispatch.length / 3;\n\n    if (checkSortFast.threadsPerWorkgroup < checkSortFull.pipelines.length || checkSortFull.threadsPerWorkgroup < initialDispatchElementCount) {\n      console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`);\n      this.checkOrder = false;\n      return;\n    }\n\n    // Create the reset pass\n    const checkSortReset = new CheckSortKernel({\n      mode: 'reset',\n      device: this.device,\n      data: this.buffers.keys!,\n      original: this.buffers.originalDispatchSize!,\n      result: this.buffers.dispatchSize!,\n      isSorted: this.buffers.isSorted!,\n      count: initialDispatchElementCount,\n      workgroupSize: findOptimalDispatchSize(this.device, initialDispatchElementCount),\n    });\n\n    this.kernels.checkSort = {\n      reset: checkSortReset,\n      fast: checkSortFast,\n      full: checkSortFull,\n    };\n  }\n\n  private createBlockSumPipeline(inKeys: GPUBuffer, inValues: GPUBuffer, bit: number) {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-block-sum',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type: this.localShuffle\n              ? 'storage' as GPUBufferBindingType\n              : 'read-only-storage' as GPUBufferBindingType,\n          }\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        }] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inKeys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: this.buffers.localPrefixSum! },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.prefixBlockSum! },\n        },\n        // \"Local shuffle\" optimization needs access to the values buffer\n        ...(this.localShuffle && this.hasValues ? [{\n          binding: 3,\n          resource: { buffer: inValues }\n        }] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const blockSumPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-block-sum',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.blockSum,\n        entryPoint: 'radix_sort',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: blockSumPipeline,\n      bindGroup,\n    };\n  }\n\n  createReorderPipeline(inKeys: GPUBuffer, inValues: GPUBuffer, outKeys: GPUBuffer, outValues: GPUBuffer, bit: number) {\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'radix-sort-reorder',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'read-only-storage' as GPUBufferBindingType },\n          },\n          {\n            binding: 5,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'storage' as GPUBufferBindingType },\n          },\n        ] : []),\n      ],\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: inKeys },\n        },\n        {\n          binding: 1,\n          resource: { buffer: outKeys },\n        },\n        {\n          binding: 2,\n          resource: { buffer: this.buffers.localPrefixSum! },\n        },\n        {\n          binding: 3,\n          resource: { buffer: this.buffers.prefixBlockSum! },\n        },\n        ...(this.hasValues ? [\n          {\n            binding: 4,\n            resource: { buffer: inValues },\n          },\n          {\n            binding: 5,\n            resource: { buffer: outValues },\n          },\n        ] : []),\n      ],\n    });\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const reorderPipeline = this.device.createComputePipeline({\n      label: 'radix-sort-reorder',\n      layout: pipelineLayout,\n      compute: {\n        module: this.shaderModules.reorder,\n        entryPoint: 'radix_sort_reorder',\n        constants: {\n          'WORKGROUP_SIZE_X': this.workgroupSize.x,\n          'WORKGROUP_SIZE_Y': this.workgroupSize.y,\n          'WORKGROUP_COUNT': this.workgroupCount,\n          'THREADS_PER_WORKGROUP': this.threadsPerWorkgroup,\n          'ELEMENT_COUNT': this.count,\n          'CURRENT_BIT': bit,\n        },\n      },\n    });\n\n    return {\n      pipeline: reorderPipeline,\n      bindGroup,\n    };\n  }\n\n  /**\n   * Encode all pipelines into the current pass\n   * \n   * @param {GPUComputePassEncoder} pass \n   */\n  dispatch(pass: GPUComputePassEncoder) {\n    if (!this.checkOrder) {\n      this.#dispatchPipelines(pass);\n    } else {\n      this.#dispatchPipelinesIndirect(pass);\n    }\n  }\n\n  /**\n   * Dispatch workgroups from CPU args\n   */\n  #dispatchPipelines(pass: GPUComputePassEncoder) {\n    for (let i = 0; i < this.bitCount / 2; i += 1) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n    }\n  }\n\n  /**\n   * Dispatch workgroups from indirect GPU buffers (used when checkOrder is enabled)\n   */\n  #dispatchPipelinesIndirect(pass: GPUComputePassEncoder) {\n    // Reset the `dispatch` and `is_sorted` buffers\n    this.kernels.checkSort!.reset.dispatch(pass);\n\n    for (let i = 0; i < this.bitCount / 2; i++) {\n      const blockSumPipeline = this.pipelines[i * 2];\n      const reorderPipeline = this.pipelines[i * 2 + 1];\n\n      if (i % 2 == 0) {\n        // Check if the data is sorted every 2 passes\n        this.kernels.checkSort!.fast.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.checkSortFast);\n        this.kernels.checkSort!.full.dispatch(pass, this.buffers.checkSortFullDispatchSize);\n      }\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum!.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefixSum);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize!, this.dispatchOffsets.radixSort);\n    }\n  }\n}\n"],"names":["findOptimalDispatchSize","device","workgroupCount","dispatchSize","x","y","createBufferFromData","label","data","usage","dispatchSizes","prefixSumSource","prefixSumSourceNoBankConflict","AbstractKernel","count","workgroupSize","PrefixSumKernel","avoidBankConflicts","blockSumBuffer","bindGroupLayout","bindGroup","pipelineLayout","scanPipeline","blockSumPipeline","p","pass","dispatchSizeBuffer","offset","pipeline","i","checkSortSource","isFirstPass","isLastPass","kernelMode","first_pass_load_data","last_pass","write_reduction_result","last_pass_full","last_pass_fast","CheckSortKernel","result","original","isSorted","start","mode","itemCount","threadsPerWorkgroup","sizes","targetWorkgroupCount","buffer","passIndex","outputBuffer","elementCount","startElement","checkSortPipeline","dispatchIndirect","radixSortSource","radixSortSource_LocalShuffle","reorderSource","RadixSortKernel","texture","keys","values","bitCount","checkOrder","localShuffle","removeValues","source","line","blockSumSource","dispatchData","bit","even","inKeys","inValues","outKeys","outValues","reorderPipeline","prefixBlockSumBuffer","prefixSumKernel","prefixSumDispatchSize","checkSortFastCount","checkSortFullCount","startFull","dispatchSizesFast","dispatchSizesFull","initialDispatch","tmpKeysBuffer","tmpValuesBuffer","localPrefixSumBuffer","dispatchBuffer","originalDispatchBuffer","checkSortFullDispatchBuffer","checkSortFullOriginalDispatchBuffer","isSortedBuffer","checkSortPartitionData","checkSortFull","checkSortFast","initialDispatchElementCount","checkSortReset","#dispatchPipelinesIndirect","#dispatchPipelines"],"mappings":"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"}